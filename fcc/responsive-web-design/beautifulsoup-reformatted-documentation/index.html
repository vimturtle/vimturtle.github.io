<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="assets/css/styles.css" />
    <link rel="stylesheet" href="minireset.css" />
    <!-- <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/pojoaque.min.css"
    /> -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/styles/dracula.min.css"
    />
    <link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/simplebar@latest/dist/simplebar.css"
/>
    <title>FCC1.4-BeautifulSoup-Reformatted-Documentation</title>
  </head>
  <body>
    <header id="main-header">
      <a href="#"><h1 id="main-title">Beautiful Soup 4.8.1 Reformatted Documentation</h1></a>
      <p>
        [
        <a
          href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.html#"
          >Official Documentation</a
        >
        ] [
        <a
          href="https://bazaar.launchpad.net/~leonardr/beautifulsoup/bs4/view/head:/doc/source/index.rst"
          >Original Source</a
        >
        ] [
        <a
          href="https://github.com/vimturtle/"
          >Source</a
        >
        ]
      </p>
      <p>
        [ Last synced with official docs:
        <span class="sync-date">Jan 18, 2020</span>]
      </p>
    </header>
    <main id="main-doc">
      <nav id="navbar" data-simplebar>
        <header>Contents</header>
        <ul>
          <li>
            <details open
              ><summary
                ><a href="#1Introduction#" class="nav-link"
                  ><span class="navbar-number">1</span>Introduction<span class="fcc">#</span></a
                ></summary
              >
              <ul>
                <li><a href="#Getting_Help" class="nav-sub-link"
                  >1.1 Getting Help</a
                ></li>
              </ul>
            </details>
          </li>

          <li>
            <details
              ><summary
                ><a href="#2Quickstart#" class="nav-link"
                  ><span class="navbar-number">2</span>Quickstart<span class="fcc">#</span></a
                ></summary
              >
              <ul></ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#3Installing_Beautiful_Soup#" class="nav-link"
                  ><span class="navbar-number">3</span>Installing Beautiful Soup<span class="fcc">#</span></a
                ></summary
              >
              <ul>
                <li><a href="#Problems_After_Installation"  class="nav-sub-link">3.1 Problems after installation</a></li>
                <li><a href="#Installing_A_Parser"  class="nav-sub-link">3.2 Installing a parser</a></li>
              </ul>
            </details>
          </li>

          <li>
            <details
              ><summary
                ><a href="#4Making_the_Soup#" class="nav-link"><span class="navbar-number">4</span>Making the Soup<span class="fcc">#</span></a></summary
              >
              <ul>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#5Kinds_of_objects#" class="nav-link"><span class="navbar-number">5</span>Kinds of objects<span class="fcc">#</span></a></summary
              >
              <ul>
                <li><a href="#Tag" class="nav-sub-link">5.1 <code class="inline-code">Tag</code></a></li>
                <li><a href="#Name" class="nav-sub-link2">5.1.1 Name</a></li>
                <li><a href="#Attributes" class="nav-sub-link2">5.1.2 Attributes</a></li>
                <li><a href="#Multi_Valued_Attributes" class="nav-sub-link3">5.1.2.1 Multi-valued attributes</a></li>
                <li><a href="#NavigableString" class="nav-sub-link">5.2 <code class="inline-code">NavigableString</code></a></li>
                <li><a href="#BeautifulSoup" class="nav-sub-link">5.3 <code class="inline-code">BeautifulSoup</code></a></li>
                <li><a href="#Comments_And_Other_Special_Strings" class="nav-sub-link">5.4 Comments and other special strings</a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#6Navigating_the_tree#" class="nav-link"
                  ><span class="navbar-number">6</span>Navigating the tree<span class="fcc">#</span></a
                ></summary
              >
              <ul>
                <li><a href="#Going_Down" class="nav-sub-link">6.1 Going down</a></li>
                <li><a href="#Navigating_Using_Tag_Names" class="nav-sub-link nav-sub-link2">6.1.1 Navigating using tag names</a></li>
                <li><a href="#contents_and_children" class="nav-sub-link nav-sub-link2">6.1.2 <code class="inline-code">.contents</code> and <code class="inline-code">.children</code></a></li>
                <li><a href="#descendents" class="nav-sub-link nav-sub-link2">6.1.3 <code class="inline-code">.descendents</code></a></li>
                <li><a href="#string" class="nav-sub-link nav-sub-link2">6.1.4 <code class="inline-code">.string</code></a></li>
                <li><a href="#strings_and_stripped_strings" class="nav-sub-link nav-sub-link2">6.1.5 <code class="inline-code">.strings</code> and <code class="inline-code">.stripped_strings</code></a></li>
                <li><a href="#Going_Up" class="nav-sub-link">6.2 Going up</a></li>
                <li><a href="#parent" class="nav-sub-link2">6.2.1 <code class="inline-code">.parent</code></a></li>
                <li><a href="#parents" class="nav-sub-link2">6.2.2 <code class="inline-code">.parents</code></a></li>
                <li><a href="#Going_Sideways" class="nav-sub-link">6.3 Going sideways</a></li>
                <li><a href="#next_sibling_and_previous_sibling" class="nav-sub-link2">6.3.1 <code class="inline-code">.next_sibling</code> and <code class="inline-code">.previous_sibling</code></a></li>
                <li><a href="#next_siblings_and_previous_siblings" class="nav-sub-link2">6.3.2 <code class="inline-code">.next_siblings</code> and <code class="inline-code">.previous_siblings</code></a></li>
                <li><a href="#Going_Back_And_Forth" class="nav-sub-link">6.4 Going back and forth</a></li>
                <li><a href="#next_element_and_previous_element" class="nav-sub-link2">6.4.1 <code class="inline-code">.next_element</code> and <code class="inline-code">.previous_element</code></a></li>
                <li><a href="#next_elements_and_previous_elements" class="nav-sub-link2">6.4.2 <code class="inline-code">.next_elements</code> and <code class="inline-code">.previous_elements</code></a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#7Searching_the_tree#" class="nav-link"><span class="navbar-number">7</span>Searching the tree<span class="fcc">#</span></a></summary
              >
              <ul>
                <li><a href="#Kinds_Of_Filters" class="nav-sub-link">7.1 Kinds of filters</a></li>
                <li><a href="#A_String" class="nav-sub-link2">7.1.1 A string</a></li>
                <li><a href="#A_Regular_Expression" class="nav-sub-link2">7.1.2 A regular expression</a></li>
                <li><a href="#A_List" class="nav-sub-link2">7.1.3 A list</a></li>
                <li><a href="#True" class="nav-sub-link2">7.1.4 <code class="inline-code">True</code></a></li>
                <li><a href="#A_Function" class="nav-sub-link2">7.1.5 A function</a></li>
                <li><a href="#find_all" class="nav-sub-link">7.2 <code class="inline-code">find_all()</code></a></li>
                <li><a href="#The_name_Argument" class="nav-sub-link2">7.2.1 The <code class="inline-code">.name</code> argument</a></li>
                <li><a href="#The_Keyword_Arguments" class="nav-sub-link2">7.2.2 The keyword arguments</a></li>
                <li><a href="#Searching_By_CSS_Class" class="nav-sub-link2">7.2.3 Searching by CSS class</a></li>
                <li><a href="#The_string_Argument" class="nav-sub-link2">7.2.4 The <code class="inline-code">string</code> argument</a></li>
                <li><a href="#The_limit_Argument" class="nav-sub-link2">7.2.5 The <code class="inline-code">limit</code> argument</a></li>
                <li><a href="#The_recursive_Argument" class="nav-sub-link2">7.2.6 The <code class="inline-code">recursive</code> argument</a></li>
                <li><a href="#Calling_A_Tag_Is_Like_Calling_find_all" class="nav-sub-link">7.3 Calling a tag is like calling <code class="inline-code">find_all()</code></a></li>
                <li><a href="#find" class="nav-sub-link">7.4 <code class="inline-code">find()</code></a></li>
                <li><a href="#find_parents_and_find_parent" class="nav-sub-link">7.5 <code class="inline-code">find_parents()</code> and <code class="inline-code">find_parent()</code></a></li>
                <li><a href="#find_next_siblings_and_find_next_sibling" class="nav-sub-link">7.6 <code class="inline-code">find_next_siblings()</code> and <code class="inline-code">find_next_sibling()</code></a></li>
                <li><a href="#find_previous_siblings_and_find_previous_sibling" class="nav-sub-link">7.7 <code class="inline-code">find_previous_siblings()</code> and <code class="inline-code">find_previous_sibling()</code></a></li>
                <li><a href="#find_all_next_and_find_next" class="nav-sub-link">7.8 <code class="inline-code">find_all_next()</code> and <code class="inline-code">find_next()</code></a></li>
                <li><a href="#find_all_previous_and_find_previous" class="nav-sub-link">7.9 <code class="inline-code">find_all_previous()</code> and <code class="inline-code">find_previous()</code></a></li>
                <li><a href="#CSS_Selectors" class="nav-sub-link">7.10 CSS selectors</a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#8Modifying_the_tree#" class="nav-link"><span class="navbar-number">8</span>Modifying the tree<span class="fcc">#</span></a></summary
              >
              <ul>
                <li><a href="#Changing_Tag_Names_And_Attributes" class="nav-sub-link">8.1 Changing tag names and attributes</a></li>
                <li><a href="#Modifying_string" class="nav-sub-link">8.2 Modifying <code class="inline-code">.string</code></a></li>
                <li><a href="#append" class="nav-sub-link">8.3 <code class="inline-code">append()</code></a></li>
                <li><a href="#extend" class="nav-sub-link">8.4 <code class="inline-code">extend()</code></a></li>
                <li><a href="#NavigableString_And_new_tag" class="nav-sub-link">8.5 <code class="inline-code">NavigableString()</code> and <code class="inline-code">.new_tag()</code></a></li>
                <li><a href="#insert" class="nav-sub-link">8.6 <code class="inline-code">insert()</code></a></li>
                <li><a href="#insert_before_And_insert_after" class="nav-sub-link">8.7 <code class="inline-code">insert_before()</code> and <code class="inline-code">insert_after()</code></a></li>
                <li><a href="#clear" class="nav-sub-link">8.8 <code class="inline-code">clear()</code></a></li>
                <li><a href="#extract" class="nav-sub-link">8.9 <code class="inline-code">extract()</code></a></li>
                <li><a href="#decompose" class="nav-sub-link">8.10 <code class="inline-code">decompose()</code></a></li>
                <li><a href="#replace_with" class="nav-sub-link">8.11 <code class="inline-code">replace_with()</code></a></li>
                <li><a href="#wrap" class="nav-sub-link">8.12 <code class="inline-code">wrap()</code></a></li>
                <li><a href="#unwrap" class="nav-sub-link">8.13 <code class="inline-code">unwrap()</code></a></li>
                <li><a href="#smooth" class="nav-sub-link">8.14 <code class="inline-code">smooth()</code></a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary><a href="#9Output#" class="nav-link"><span class="navbar-number">9</span>Output<span class="fcc">#</span></a></summary>
              <ul>
                <li><a href="#Pretty_Printing" class="nav-sub-link">9.1 Pretty-printing</a></li>
                <li><a href="#Non_Pretty_Printing" class="nav-sub-link">9.2 Non-pretty printing</a></li>
                <li><a href="#Output_Formatters" class="nav-sub-link">9.3 Output formatters</a></li>
                <li><a href="#get_text" class="nav-sub-link">9.4 <code class="inline-code">get_text()</code></a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#10Specifying_the_parser_to_use#" class="nav-link"
                  ><span class="navbar-number">10</span>Specifying the parser to use<span class="fcc">#</span></a
                ></summary
              >
              <ul>
                <li><a href="#Differences_Between_Parsers" class="nav-sub-link">10.1 Differences between parsers</a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary><a href="#11Encodings#" class="nav-link"><span class="navbar-number">11</span>Encodings<span class="fcc">#</span></a></summary>
              <ul>
                <li><a href="#Output_Encoding" class="nav-sub-link">11.1 Output encoding</a></li>
                <li><a href="#Unicode_Dammit" class="nav-sub-link">11.2 Unicode, Dammit</a></li>
                <li><a href="#Smart_Quotes" class="nav-sub-link2">11.2.1 Smart quotes</a></li>
                <li><a href="#Inconsistent_Encodings" class="nav-sub-link2">11.2.2 Inconsistent encodings</a></li></ul>
            </details>
          </li>

          <li>
            <details
              ><summary
                ><a href="#12Line_numbers#" class="nav-link"><span class="navbar-number">12</span>Line numbers<span class="fcc">#</span></a></summary
              >
              <ul></ul>
            </details>
          </li>

          <li>
            <details
              ><summary
                ><a href="#13Comparing_objects_for_equality#" class="nav-link"
                  ><span class="navbar-number">13</span>Comparing objects for equality<span class="fcc">#</span></a
                ></summary
              >
              <ul></ul>
            </details>
          </li>

          <li>
            <details
              ><summary
                ><a href="#14Copying_Beautiful_Soup_objects#" class="nav-link"
                  ><span class="navbar-number">14</span>Copying Beautiful Soup objects<span class="fcc">#</span></a
                ></summary
              >
              <ul></ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#15Parsing_only_part_of_a_document#" class="nav-link"
                  ><span class="navbar-number">15</span>Parsing only part of a document<span class="fcc">#</span></a
                ></summary
              >
              <ul>
                <li><a href="#SoupStrainer" class="nav-sub-link">15.1 <code class="inline-code">SoupStrainer</code></a></li>
              </ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#16Troubleshooting#" class="nav-link"><span class="navbar-number">16</span>Troubleshooting<span class="fcc">#</span></a></summary
              >
              <ul>
                <li><a href="#diagnose" class="nav-sub-link">16.1 <code class="inline-code">diagnose()</code></a></li>
                <li><a href="#Errors_When_Parsing_A_Document" class="nav-sub-link">16.2 Errors when parsing a document</a></li>
                <li><a href="#Version_Mismatch_Problems" class="nav-sub-link">16.3 Version mismatch problems</a></li>
                <li><a href="#Parsing_XML" class="nav-sub-link">16.4 Parsing XML</a></li>
                <li><a href="#Other_Parser_Problems" class="nav-sub-link">16.5 Other parser problems</a></li>
                <li><a href="#Miscellaneous" class="nav-sub-link">16.6 Miscellaneous</a></li>
                <li><a href="#Improving_Performance" class="nav-sub-link">16.7 Improving Performance</a></li>
              </ul>
            </details>
          </li>

          <li>
            <details
              ><summary
                ><a href="#17Translating_this_document#" class="nav-link"
                  ><span class="navbar-number">17</span>Translating this document<span class="fcc">#</span></a
                ></summary
              >
              <ul></ul>
            </details>
          </li>

          <li>
            <details open
              ><summary
                ><a href="#18Beautiful_Soup_3#" class="nav-link"><span class="navbar-number">18</span>Beautiful Soup 3<span class="fcc">#</span></a></summary
              >
              <ul>
                <li><a href="#Porting_Code_To_BS4" class="nav-sub-link">18.1 Porting code to BS4</a></li>
                <li><a href="#You_Need_A_Parser" class="nav-sub-link2">18.1.1 You need a parser</a></li>
                <li><a href="#Method_Names" class="nav-sub-link2">18.1.2 Method names</a></li>
                <li><a href="#Generators" class="nav-sub-link2">18.1.3 Generators</a></li>
                <li><a href="#XML" class="nav-sub-link2">18.1.4 XML</a></li>
                <li><a href="#Entities" class="nav-sub-link2">18.1.5 Entities</a></li>
                <li><a href="#Miscellaneous2" class="nav-sub-link2">18.1.6 Miscellaneous</a></li>
              </ul>
            </details>
          </li>
        </ul>
      </nav>

      <div class="main-content">
        <section class="main-section" id="1Introduction#">
          <header>
            <span class="number section-number">1</span>Introduction<a
              class="header-anchor"
              href="#1Introduction#"
              >#</a
            >
          </header>

          <p>
            <a href="http://www.crummy.com/software/BeautifulSoup/"
              >Beautiful Soup</a
            >
            is a Python library for pulling data out of HTML and XML files. It
            works with your favorite parser to provide idiomatic ways of
            navigating, searching, and modifying the parse tree. It commonly
            saves programmers hours or days of work.
          </p>
          <p>
            These instructions illustrate all major features of Beautiful Soup
            4, with examples. I show you what the library is good for, how it
            works, how to use it, how to make it do what you want, and what to
            do when it violates your expectations.
          </p>
          <p>
            This document covers Beautiful Soup version 4.8.1. The examples in
            this documentation should work the same way in Python 2.7 and Python
            3.2.
          </p>
          <p>
            You might be looking for the documentation for
            <a
              href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html"
              >Beautiful Soup 3</a
            >. If so, you should know that Beautiful Soup 3 is no longer being
            developed and that support for it will be dropped on or after
            December 31, 2020. If you want to learn about the differences
            between Beautiful Soup 3 and Beautiful Soup 4, see
            <a href="#porting-code-to-bs4">Porting code to BS4</a>.
          </p>
          <p>
            This documentation has been translated into other languages by
            Beautiful Soup users:
          </p>
          <ul>
            <li>
              <a
                href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/"
                >这篇文档当然还有中文版.</a
              >
            </li>
            <li>
              このページは日本語で利用できます(<a href="http://kondou.com/BS4/"
                >外部リンク</a
              >)
            </li>
            <li>
              <a
                href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ko/"
                >이 문서는 한국어 번역도 가능합니다.</a
              >
            </li>
            <li>
              <a
                href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.ptbr/"
                >Este documento também está disponível em Português do
                Brasil.</a
              >
            </li>
          </ul>

          <h4 class="sub-header" id="Getting_Help">
            <span class="number sub-section-number">1.1</span>Getting Help<a
              class="header-anchor"
              href="#Getting_Help"
              >#</a
            >
          </h4>
          <p>
            If you have questions about Beautiful Soup, or run into problems,<a
              href="https://groups.google.com/forum/?fromgroups#!forum/beautifulsoup"
            >
              send mail to the discussion group</a
            >. If your problem involves parsing an HTML document, be sure to
            mention
            <a href="#diagnose"
              ><span>what the diagnose() function says</span></a
            >
            about that document.
          </p>
        </section>

        <section class="main-section" id="2Quickstart#">
          <header>
            <span class="number section-number">2</span>Quickstart<a
              class="header-anchor"
              href="#2Quickstart#"
              >#</a
            >
          </header>
          <p>
            Here's an HTML document I'll be using as an example throughout this
            document. It's part of a story from
            <i>Alice in Wonderland</i>:
          </p>
          <pre><code class="python">html_doc = &quot;&quot;&quot;
              &lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
              &lt;body&gt;
              &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;
              
              &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
              &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
              &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
              &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
              and they lived at the bottom of a well.&lt;/p&gt;
              
              &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;
              &quot;&quot;&quot;</code></pre>

          <p>
            Running the “three sisters” document through Beautiful Soup gives us
            a <code class="inline-code object">BeautifulSoup</code> object,
            which represents the document as a nested data structure:
          </p>
          <pre><code class="python">from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')

print(soup.prettify())
# &lt;html&gt;
#  &lt;head&gt;
#   &lt;title&gt;
#    The Dormouse's story
#   &lt;/title&gt;
#  &lt;/head&gt;
#  &lt;body&gt;
#   &lt;p class=&quot;title&quot;&gt;
#    &lt;b&gt;
#     The Dormouse's story
#    &lt;/b&gt;
#   &lt;/p&gt;
#   &lt;p class=&quot;story&quot;&gt;
#    Once upon a time there were three little sisters; and their names were
#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;
#     Elsie
#    &lt;/a&gt;
#    ,
#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;
#     Lacie
#    &lt;/a&gt;
#    and
#    &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;
#     Tillie
#    &lt;/a&gt;
#    ; and they lived at the bottom of a well.
#   &lt;/p&gt;
#   &lt;p class=&quot;story&quot;&gt;
#    ...
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre>

          <p>Here are some simple ways to navigate that data structure:</p>
          <pre><code class="python">soup.title
# &lt;title&gt;The Dormouse's story&lt;/title&gt;

soup.title.name
# u'title'

soup.title.string
# u'The Dormouse's story'

soup.title.parent.name
# u'head'

soup.p
# &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;

soup.p['class']
# u'title'

soup.a
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;

soup.find_all('a')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.find(id=&quot;link3&quot;)
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;</code></pre>

          <p>
            One common task is extracting all the URLs found within a page’s
            <code class="inline-code tag">&lt;a></code> tags:
          </p>
          <pre><code class="python">for link in soup.find_all('a'):
    print(link.get('href'))
# http://example.com/elsie
# http://example.com/lacie
# http://example.com/tillie</code></pre>

          <p>Another common task is extracting all the text from a page:</p>
          <pre><code class="python">print(soup.get_text())
# The Dormouse's story
#
# The Dormouse's story
#
# Once upon a time there were three little sisters; and their names were
# Elsie,
# Lacie and
# Tillie;
# and they lived at the bottom of a well.
#
# ...</code></pre>

          <p>Does this look like what you need? If so, read on.</p>
        </section>

        <section class="main-section" id="3Installing_Beautiful_Soup#">
          <header>
            <span class="number section-number">3</span>Installing Beautiful
            Soup<a class="header-anchor" href="#3Installing_Beautiful_Soup#">#</a>
          </header>

          <p>
            If you’re using a recent version of Debian or Ubuntu Linux, you can
            install Beautiful Soup with the system package manager:
          </p>
          <p>
            <code class="inline-code bash">$ apt-get install python-bs4</code>
            (for python 2)
          </p>
          <p>
            <code class="inline-code bash">$ apt-get install python3-bs4</code>
            (for python 3)
          </p>
          <p>
            Beautiful Soup 4 is published through PyPi, so if you can’t install
            it with the system packager, you can install it with
            <code class="inline-code">easy_install</code> or
            <code class="inline-code">pip</code>. The package name is
            <code class="inline-code">beautifulsoup4</code>, and the same
            package works on Python 2 and Python 3. Make sure you use the right
            version of <code class="inline-code">pip</code> or
            <code class="inline-code">easy_install</code> for your Python
            version (these may be named
            <code class="inline-code">pip3</code> and
            <code class="inline-code">easy_install3</code> respectively if
            you’re using Python 3).
          </p>
          <p>
            <code class="inline-code">$ easy_install beautifulsoup4</code>
          </p>
          <p>
            <code class="inline-code">$ pip install beautifulsoup4</code>
          </p>
          <p>
            (The
            <code class="inline-code">BeautifulSoup</code>
            package is probably <i>not</i> what you want. That's the previous
            major release,
            <a
              href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html"
              >Beautiful Soup 3</a
            >. Lots of software uses BS3, so it's still available, but if you're
            writing new code you should install
            <code class="inline-code">beautifulsoup4</code>.)
          </p>
          <p>
            If you don't have
            <code class="inline-code">easy_install</code
            >
            or
            <code class="inline-code">pip</code>
            installed, you can
            <a href="http://www.crummy.com/software/BeautifulSoup/download/4.x/"
              >download the Beautiful Soup 4 source tarball</a
            >
            and install it with
            <code class="inline-code">setup.py</code></code
            >.
          </p>
          <p><code class="inline-code">$ python setup.py install</code></p>
          <p>If all else fails, the license for Beautiful Soup allows you to package the entire library with your application. You can download the tarball, copy its <code class="inline-code">bs4</code> directory into your application’s codebase, and use Beautiful Soup without installing it at all.</p>
          <p>I use Python 2.7 and Python 3.2 to develop Beautiful Soup, but it should work with other recent versions.</p>

          <h4 class="sub-header" id="Problems_After_Installation">
            <span class="number sub-section-number">3.1</span>Problems after installation<a
              class="header-anchor"
              href="#Problems_After_Installation"
              >#</a
            >
          </h4>
          <p>Beautiful Soup is packaged as Python 2 code. When you install it for
            use with Python 3, it's automatically converted to Python 3 code. If
            you don't install the package, the code won't be converted. There have
            also been reports on Windows machines of the wrong version being
            installed.</p>
            <p>If you get the <code class="inline-code">ImportError</code> "No module named HTMLParser", your
            problem is that you're running the Python 2 version of the code under
            Python 3.</p>
            <p>If you get the <code class="inline-code">ImportError</code> "No module named html.parser", your
            problem is that you're running the Python 3 version of the code under
            Python 2.</p>
            <p>In both cases, your best bet is to completely remove the Beautiful
            Soup installation from your system (including any directory created
            when you unzipped the tarball) and try the installation again.</p>
            <p>If you get the <code class="inline-code">SyntaxError</code> "Invalid syntax" on the line
            <code class="inline-code">ROOT_TAG_NAME = u'[document]'</code>, you need to convert the Python 2
            code to Python 3. You can do this either by installing the package:</p>
            <p><code class="inline-code">$ python3 setup.py install</code></p>
            <p>or by manually running Python's <code class="inline-code">2to3</code> conversion script on the
            <code class="inline-code">bs4</code> directory:</p>
            <p><code class="inline-code">$ 2to3-3.2 -w bs4</code></p>
            

          <h4 class="sub-header" id="Installing_A_Parser">
            <span class="number sub-section-number">3.1</span>Installing a parser<a
              class="header-anchor"
              href="#Installing_A_Parser"
              >#</a
            >
          </h4>
          <p>Beautiful Soup supports the HTML parser included in Python&#8217;s standard
            library, but it also supports a number of third-party Python parsers.
            One is the <a href="http://lxml.de/">lxml parser</a>. Depending on your setup,
            you might install lxml with one of these commands:</p>
            <p><code class="inline-code">$ apt-get install python-lxml</code></p>
            <p><code class="inline-code">$ easy_install lxml</code></p>
            <p><code class="inline-code">$ pip install lxml</code></p>
            <p>Another alternative is the pure-Python <a href="http://code.google.com/p/html5lib/">html5lib parser</a>, which parses HTML the way a
            web browser does. Depending on your setup, you might install html5lib
            with one of these commands:</p>
            <p><code class="inline-code">$ apt-get install python-html5lib</code></p>
            <p><code class="inline-code">$ easy_install html5lib</code></p>
            <p><code class="inline-code">$ pip install html5lib</code></p>
            <p>This table summarizes the advantages and disadvantages of each parser library:</p>

            <table>
              <thead>
                <tr>
                  <th scope="col" class="hello">Parser</th>
                  <th scope="col">Typical usage</th>
                  <th scope="col">Advantages</th>
                  <th scope="col">Disadvantages</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <th scope="row">Python’s html.parser</th>
                  <td><code class="inline-code">BeautifulSoup(markup, "html.parser")</code></td>
                  <td>
                    <ul>
                      <li>Batteries included</li>
                      <li>Decent speed</li>
                      <li>Lenient (As of Python 2.7.3 and 3.2.)</li>
                    </ul>
                  </td>
                  <td>
                    <ul>
                      <li>Not as fast as lxml, less lenient than html5lib.</li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <th scope="row">lxml’s HTML parser</th>
                  <td><code class="inline-code">BeautifulSoup(markup, "lxml")</code></td>
                  <td>
                    <ul>
                      <li>Very fast</li>
                      <li>Lenient</li>
                    </ul>
                  </td>
                  <td>
                    <ul>
                      <li>External C dependency</li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <th scope="row">lxml’s XML parser</th>
                  <td><code class="inline-code">BeautifulSoup(markup, "lxml-xml")</code><br /><code class="inline-code">BeautifulSoup(markup, "xml")</code></td>
                  <td>
                    <ul>
                      <li>Very fast</li>
                      <li>The only currently supported XML parser</li>
                    </ul>
                  </td>
                  <td>
                    <ul>
                      <li>External C dependency</li>
                    </ul>
                  </td>
                </tr>
                <tr>
                  <th scope="row">html5lib</th>
                  <td><code class="inline-code">BeautifulSoup(markup, "html5lib")</code></td>
                  <td>
                    <ul>
                      <li>Extremely lenient</li>
                      <li>Parses pages the same way a web browser does</li>
                      <li>Creates valid HTML5</li>
                    </ul>
                  </td>
                  <td>
                    <ul>
                      <li>Very slow</li>
                      <li>External Python dependency</li>
                    </ul>
                  </td>
                </tr>
              </tbody>
            </table>

            <p>If you can, I recommend you install and use lxml for speed. If you’re using a version of Python 2 earlier than 2.7.3, or a version of Python 3 earlier than 3.2.2, it’s essential that you install lxml or html5lib–Python’s built-in HTML parser is just not very good in older versions.</p>
            <p>Note that if a document is invalid, different parsers will generate different Beautiful Soup trees for it. See <a href="#Differences_Between_Parsers">Differences between parsers</a> for details.</p>

        </section>

        <section class="main-section" id="4Making_the_Soup#">
          <header><span class="number section-number">4</span>Making the Soup<a class="header-anchor" href="#4Making_the_Soup#">#</a></header>
          <p>To parse a document, pass it into the <code class="inline-code">BeautifulSoup</code> constructor. You can pass in a string or an open filehandle:</p>
          <pre><code class="python">from bs4 import BeautifulSoup

with open("index.html") as fp:
    soup = BeautifulSoup(fp)

soup = BeautifulSoup("<html>data</html>")</code></pre>

          <p>First, the document is converted to Unicode, and HTML entities are converted to Unicode characters:</p>
          <pre><code class="python">BeautifulSoup(&quot;Sacr&amp;eacute; bleu!&quot;)
&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Sacr&eacute; bleu!&lt;/body&gt;&lt;/html&gt;</code></pre>

          <p>Beautiful Soup then parses the document using the best available parser. It will use an HTML parser unless you specifically tell it to use an XML parser. (See <a href="#Parsing_XML">Parsing XML</a>.)</p>
        </section>

        <section class="main-section" id="5Kinds_of_objects#">
          <header><span class="number section-number">5</span>Kinds of objects<a class="header-anchor" href="#5Kinds_of_objects#">#</a></header>
          <p>Beautiful Soup transforms a complex HTML document into a complex tree of Python objects. But you’ll only ever have to deal with about four kinds of objects: <code class="inline-code">Tag</code>, <code class="inline-code">NavigableString</code>, <code class="inline-code">BeautifulSoup</code>, and <code class="inline-code">Comment</code>.</p>
          <h4 class="sub-header" id="Tag">
            <span class="number sub-section-number">5.1</span>Tag<a class="header-anchor" href="#Tag">#</a>
          </h4>
          <p>A <code class="inline-code">Tag</code> object corresponds to an XML or HTML tag in the original document:</p>
          <pre><code class="python">soup = BeautifulSoup('&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;')
tag = soup.b
type(tag)
# &lt;class 'bs4.element.Tag'&gt;</code></pre>

          <p>Tags have a lot of attributes and methods, and I’ll cover most of them in <a href="#Navigating_The_Tree">Navigating the tree</a> and <a href="#Searching_The_Tree">Searching the tree</a>. For now, the most important features of a tag are its name and attributes.</p>

          <h5 class="sub-header sub-header2" id="Name">
            <span class="number sub-section-number">5.1.1</span>Name<a class="header-anchor" href="#Name">#</a>
          </h5>
          <p>Every tag has a name, accessible as <code class="inline-code">.name</code>:</p>
          <pre><code class="python">tag.name
# u'b'</code></pre>
          <p>If you change a tag’s name, the change will be reflected in any HTML markup generated by Beautiful Soup:</p>
          <pre><code class="python">tag.name = &quot;blockquote&quot;
tag
# &lt;blockquote class=&quot;boldest&quot;&gt;Extremely bold&lt;/blockquote&gt;</code></pre>

          <h5 class="sub-header sub-header2" id="Attributes">
            <span class="number sub-section-number">5.1.2</span>Attributes<a class="header-anchor" href="#Attributes">#</a>
          </h5>
          <p>A tag may have any number of attributes. The tag <code class="inline-code">&lt;b id=&quot;boldest&quot;&gt;</code> has an attribute “id” whose value is “boldest”. You can access a tag’s attributes by treating the tag like a dictionary:</p>
          <pre><code class="python">tag['id']
# u'boldest'</code></pre>
          
          <p>You can access that dictionary directly as <code class="inline-code">.attrs</code>:</p>
          <pre><code class="python">tag.attrs
# {u'id': 'boldest'}</code></pre>

          <p>You can add, remove, and modify a tag’s attributes. Again, this is done by treating the tag as a dictionary:</p>
          <pre><code class="python">tag['id'] = 'verybold'
tag['another-attribute'] = 1
tag
# &lt;b another-attribute=&quot;1&quot; id=&quot;verybold&quot;&gt;&lt;/b&gt;

del tag['id']
del tag['another-attribute']
tag
# &lt;b&gt;&lt;/b&gt;

tag['id']
# KeyError: 'id'
print(tag.get('id'))
# None
</code></pre>

          <h6 class="sub-header sub-header3" id="Multi_Valued_Attributes">
            <span class="number sub-section-number">5.1.2.1</span>Multi Valued Attributes<a class="header-anchor" href="#Multi_Valued_Attributes">#</a>
          </h6>
          <p>HTML 4 defines a few attributes that can have multiple values. HTML 5 removes a couple of them, but defines a few more. The most common multi-valued attribute is <code class="inline-code">class</code> (that is, a tag can have more than one CSS class). Others include <code class="inline-code">rel</code>,
          <code class="inline-code">rev</code>,
          <code class="inline-code">accept-charset</code>,
          <code class="inline-code">headers</code>, and
          <code class="inline-code">accesskey</code>. Beautiful Soup presents the value(s) of a multi-valued attribute as a list:</p>
          
          <pre><code class="python">css_soup = BeautifulSoup('&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;')
css_soup.p['class']
# [&quot;body&quot;]

css_soup = BeautifulSoup('&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;')
css_soup.p['class']
# [&quot;body&quot;, &quot;strikeout&quot;]</code></pre>

          <p>If an attribute looks like it has more than one value, but it’s not a multi-valued attribute as defined by any version of the HTML standard, Beautiful Soup will leave the attribute alone:</p>
          <pre><code class="python">id_soup = BeautifulSoup('&lt;p id=&quot;my id&quot;&gt;&lt;/p&gt;')
id_soup.p['id']
# 'my id'</code></pre>
          <p>When you turn a tag back into a string, multiple attribute values are consolidated:</p>
          <pre><code class="python">rel_soup = BeautifulSoup('&lt;p&gt;Back to the &lt;a rel=&quot;index&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;')
rel_soup.a['rel']
# ['index']
rel_soup.a['rel'] = ['index', 'contents']
print(rel_soup.p)
# &lt;p&gt;Back to the &lt;a rel=&quot;index contents&quot;&gt;homepage&lt;/a&gt;&lt;/p&gt;
</code></pre>

          <p>You can disable this by passing <code class="inline-code">multi_valued_attributes=None</code> as a keyword argument into the <code class="inline-code">BeautifulSoup</code> constructor:</p>
          <pre><code class="python">no_list_soup = BeautifulSoup('&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;', 'html', multi_valued_attributes=None)
no_list_soup.p['class']
# u'body strikeout'</code></pre>
          <p>You can use <code class="inline-code">`get_attribute_list</code> to get a value that’s always a list, whether or not it’s a multi-valued atribute:</p>
          <pre><code class="python">id_soup.p.get_attribute_list('id')
# ["my id"]</code></pre>
          <p>If you parse a document as XML, there are no multi-valued attributes:</p>
          <pre><code class="python">xml_soup = BeautifulSoup('&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;', 'xml')
xml_soup.p['class']
# u'body strikeout'</code></pre>
          <p>Again, you can configure this using the <code class="inline-code">multi_valued_attributes</code>argument:</p>
          <pre><code class="python">class_is_multi= { '*' : 'class'}
xml_soup = BeautifulSoup('&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;', 'xml', multi_valued_attributes=class_is_multi)
xml_soup.p['class']
# [u'body', u'strikeout']</code></pre>
          <p>You probably won’t need to do this, but if you do, use the defaults as a guide. They implement the rules described in the HTML specification:</p>
          <pre><code class="python">from bs4.builder import builder_registry
builder_registry.lookup('html').DEFAULT_CDATA_LIST_ATTRIBUTES</code></pre>

          <h4 class="sub-header" id="NavigableString">
            <span class="number sub-section-number">5.2</span><code class="inline-code">NavigableString</code><a class="header-anchor" href="#NavigableString">#</a>
          </h4>
          <p>A string corresponds to a bit of text within a tag. Beautiful Soup uses the <code class="inline-code">NavigableString</code> class to contain these bits of text:</p>
          <pre><code class="python">tag.string
# u'Extremely bold'
type(tag.string)
# &lt;class 'bs4.element.NavigableString'&gt;</code></pre>
          <p>A <code class="inline-code">NavigableString</code> is just like a Python Unicode string, except that it also supports some of the features described in <a href="#Navigating_The_Tree">Navigating the tree</a> and <a href="#Searching_The_Tree">Searching the tree</a>. You can convert a <code class="inline-code">NavigableString</code> to a Unicode string with <code class="inline-code">unicode()</code>:</p>
          <pre><code class="python">unicode_string = unicode(tag.string)
unicode_string
# u'Extremely bold'
type(unicode_string)
# &lt;type 'unicode'&gt;</code></pre>
          <p>You can’t edit a string in place, but you can replace one string with another, using <a href="#replace_with">replace_with()</a>:</p>
          <pre><code class="python">tag.string.replace_with(&quot;No longer bold&quot;)
tag
# &lt;blockquote&gt;No longer bold&lt;/blockquote&gt;</code></pre>
          <p><code class="inline-code">NavigableString</code> supports most of the features described in <a href="#Navigating_The_Tree">Navigating the tree</a> and <a href="#Searching_The_Tree">Searching the tree</a>, but not all of them. In particular, since a string can’t contain anything (the way a tag may contain a string or another tag), strings don’t support the <code class="inline-code">.contents</code> or <code class="inline-code">.string</code> attributes, or the <code class="inline-code">find()</code> method.</p>
          <p>If you want to use a <code class="inline-code">NavigableString</code> outside of Beautiful Soup, you should call <code class="inline-code">unicode()</code> on it to turn it into a normal Python Unicode string. If you don’t, your string will carry around a reference to the entire Beautiful Soup parse tree, even when you’re done using Beautiful Soup. This is a big waste of memory.</p>

          <h4 class="sub-header" id="BeautifulSoup">
            <span class="number sub-section-number">5.3</span><code class="inline-code">BeautifulSoup</code><a class="header-anchor" href="#BeautifulSoup">#</a>
          </h4>
          <p>The <code class="inline-code">BeautifulSoup</code> object represents the parsed document as a whole. For most purposes, you can treat it as a <a href="#Tag">Tag</a> object. This means it supports most of the methods described in <a href="#Navigating_The_Tree">Navigating the tree</a> and <a href="#Searching_The_Tree">Searching the tree</a></p>
          <p>You can also pass a <code class="inline-code">BeautifulSoup</code> object into one of the methods defined in <a href="Modifying_The_Tree">Modifying the tree</a>, just as you would a <a href="#Tag">Tag</a>. This lets you do things like combine two parsed documents:</p>
          <pre><code class="python">doc = BeautifulSoup(&quot;&lt;document&gt;&lt;content/&gt;INSERT FOOTER HERE&lt;/document&quot;, &quot;xml&quot;)
footer = BeautifulSoup(&quot;&lt;footer&gt;Here's the footer&lt;/footer&gt;&quot;, &quot;xml&quot;)
doc.find(text=&quot;INSERT FOOTER HERE&quot;).replace_with(footer)
# u'INSERT FOOTER HERE'
print(doc)
# &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
# &lt;document&gt;&lt;content/&gt;&lt;footer&gt;Here's the footer&lt;/footer&gt;&lt;/document&gt;</code></pre>
          <p>Since the <code class="inline-code">BeautifulSoup</code> object doesn’t correspond to an actual HTML or XML tag, it has no name and no attributes. But sometimes it’s useful to look at its <code class="inline-code">.name</code>, so it’s been given the special <code class="inline-code">.name</code> “[document]”:</p>
          <pre><code class="python">soup.name
# u'[document]'</code></pre>

          <h4 class="sub-header" id="Comments_And_Other_Special_Strings">
            <span class="number sub-section-number">5.4</span><code class="inline-code">Comments And Other Special Strings</code><a class="header-anchor" href="#Comments_And_Other_Special_Strings">#</a>
          </h4>
          <p><code class="inline-code">Tag</code>, <code class="inline-code">NavigableString</code>, and <code class="inline-code">BeautifulSoup</code> cover almost everything you’ll see in an HTML or XML file, but there are a few leftover bits. The only one you’ll probably ever need to worry about is the comment:</p>
          <pre><code class="python">markup = &quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;&quot;
soup = BeautifulSoup(markup)
comment = soup.b.string
type(comment)
# &lt;class 'bs4.element.Comment'&gt;</code></pre>
          <p>The <code class="inline-code">Comment</code> object is just a special type of <code class="inline-code">NavigableString</code>:</p>
          <pre><code class="python">comment
# u'Hey, buddy. Want to buy a used parser'</code></pre>
          <p>But when it appears as part of an HTML document, a <code class="inline-code">Comment</code> is displayed with special formatting:</p>
          <pre><code class="python">print(soup.b.prettify())
# &lt;b&gt;
#  &lt;!--Hey, buddy. Want to buy a used parser?--&gt;
# &lt;/b&gt;
</code></pre>
          <p>Beautiful Soup defines classes for anything else that might show up in an XML document: <code class="inline-code">CData</code>, <code class="inline-code">ProcessingInstruction</code>, <code class="inline-code">Declaration</code>, and <code class="inline-code">Doctype</code>. Just like <code class="inline-code">Comment</code>, these classes are subclasses of <code class="inline-code">NavigableString</code> that add something extra to the string. Here’s an example that replaces the comment with a CDATA block:</p>
          <pre><code class="python">from bs4 import CData
cdata = CData(&quot;A CDATA block&quot;)
comment.replace_with(cdata)

print(soup.b.prettify())
# &lt;b&gt;
#  &lt;![CDATA[A CDATA block]]&gt;
# &lt;/b&gt;</code></pre>

        </section>

        <section class="main-section" id="6Navigating_the_tree#">
          <header><span class="number section-number">6</span>Navigating the tree<a class="header-anchor" href="#6Navigating_the_tree#">#</a></header>
          <p>Here’s the “Three sisters” HTML document again:</p>
          <pre><code class="python">html_doc = &quot;&quot;&quot;
&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
and they lived at the bottom of a well.&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;
&quot;&quot;&quot;

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')</code></pre>
          <p>I’ll use this as an example to show you how to move from one part of a document to another.</p>

          <h4 class="sub-header" id="Going_Down">
            <span class="number sub-section-number">6.1</span>Going down<a class="header-anchor" href="#Going_Down">#</a>
          </h4>
          <p>Tags may contain strings and other tags. These elements are the tag’s <i>children</i>
            . Beautiful Soup provides a lot of different attributes for navigating and iterating over a tag’s children.</p>
          <p>Note that Beautiful Soup strings don’t support any of these attributes, because a string can’t have children.</p>

          <h5 class="sub-header sub-header2" id="Navigating_Using_Tag_Names">
            <span class="number sub-section-number">6.1.1</span>Navigating using tag names<a class="header-anchor" href="#Navigating_Using_Tag_Names">#</a>
          </h5>
          <p>The simplest way to navigate the parse tree is to say the name of the tag you want. If you want the <head> tag, just say <code class="inline-code">soup.head</code>:</p>
          <pre><code class="python">soup.head
# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;

soup.title
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre>
          <p>You can do use this trick again and again to zoom in on a certain part of the parse tree. This code gets the first <code class="inline-code">&lt;b&gt;</code> tag beneath the <code class="inline-code">&lt;body&gt;<body></code> tag:</p>
          <pre><code class="python">soup.body.b
# &lt;b&gt;The Dormouse's story&lt;/b&gt;</code></pre>
          <p>Using a tag name as an attribute will give you only the first tag by that name:</p>
          <pre><code class="python">soup.a
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</code></pre>
          <p>If you need to get <i>all</i> the <code class="inline-code">&lt;a></code> tags, or anything more complicated than the first tag with a certain name, you’ll need to use one of the methods described in <a href="#Searching_The_Tree">Searching the tree</a>, such as <i>find_all()</i>:</p>
          <pre><code class="python">soup.find_all('a')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</code></pre>

          <h5 class="sub-header sub-header2" id="contents_and_children">
            <span class="number sub-section-number">6.1.2</span><code class="inline-code">.contents</code> and <code class="inline-code">.children</code><a class="header-anchor" href="#contents_and_children">#</a>
          </h5>
          <p>A tag’s children are available in a list called .contents:</p>
          <pre><code class="python">head_tag = soup.head
head_tag
# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;

head_tag.contents
[&lt;title&gt;The Dormouse's story&lt;/title&gt;]

title_tag = head_tag.contents[0]
title_tag
# &lt;title&gt;The Dormouse's story&lt;/title&gt;
title_tag.contents
# [u'The Dormouse's story']</code></pre>
          <p>The BeautifulSoup object itself has children. In this case, the <html> tag is the child of the BeautifulSoup object.:</p>
          <pre><code class="python">len(soup.contents)
# 1
soup.contents[0].name
# u'html'</code></pre>
          <p>A string does not have .contents, because it can’t contain anything:</p>
          <pre><code class="python">text = title_tag.contents[0]
text.contents
# AttributeError: 'NavigableString' object has no attribute 'contents'</code></pre>
          <p>Instead of getting them as a list, you can iterate over a tag’s children using the .children generator:</p>
          <pre><code class="python">for child in title_tag.children:
    print(child)
# The Dormouse's story</code></pre>

          <h5 class="sub-header sub-header2" id="descendents">
            <span class="number sub-section-number">6.1.3</span><code class="inline-code">.descendents</code><a class="header-anchor" href="#descendents">#</a>
          </h5>
          <p>The <code class="inline-code">.contents</code> and <code class="inline-code">.children</code> attributes only consider a tag’s direct children. For instance, the <code class="inline-code">&lt;head></code> tag has a single direct child–the <code class="inline-code">&lt;title></code> tag:</p>
          <pre><code class="python">head_tag.contents
# [&lt;title>The Dormouse's story&lt;/title>]</code></pre>
          <p>But the <code class="inline-code">&lt;title></code> tag itself has a child: the string “The Dormouse’s story”. There’s a sense in which that string is also a child of the <code class="inline-code">&lt;head></code> tag. The <code class="inline-code">.descendants</code> attribute lets you iterate over all of a tag’s children, recursively: its direct children, the children of its direct children, and so on:</p>
          <pre><code class="python">for child in head_tag.descendants:
    print(child)
# &lt;title>The Dormouse's story&lt;/title>
# The Dormouse's story</code></pre>
          <p>The <code class="inline-code">&lt;head></code> tag has only one child, but it has two descendants: the <code class="inline-code">&lt;title></code> tag and the <code class="inline-code">&lt;title></code> tag’s child. The BeautifulSoup object only has one direct child (the <code class="inline-code">&lt;html></code> tag), but it has a whole lot of descendants:</p>
          <pre><code class="python">len(list(soup.children))
# 1
len(list(soup.descendants))
# 25</code></pre>

          <h5 class="sub-header sub-header2" id="string">
            <span class="number sub-section-number">6.1.4</span><code class="inline-code">.string</code><a class="header-anchor" href="#string">#</a>
          </h5>
          <p>If a tag has only one child, and that child is a <code class="inline-code">NavigableString</code>, the child is made available as <code class="inline-code">.string</code>:</p>
          <pre><code class="python">title_tag.string
# u'The Dormouse's story'</code></pre>
          <p>If a tag’s only child is another tag, and that tag has a <code class="inline-code">.string</code>, then the parent tag is considered to have the same <code class="inline-code">.string</code> as its child:</p>
          <pre><code class="python">head_tag.contents
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]

head_tag.string
# u'The Dormouse's story'</code></pre>
          <p>If a tag contains more than one thing, then it’s not clear what <code class="inline-code">.string</code> should refer to, so <code class="inline-code">.string</code> is defined to be <code class="inline-code">None</code>:</p>
          <pre><code class="python">print(soup.html.string)
# None</code></pre>

          <h5 class="sub-header sub-header2" id="strings_and_stripped_strings">
            <span class="number sub-section-number">6.1.5</span><code class="inline-code">.strings</code> and <code class="inline-code">.stripped_strings</code><a class="header-anchor" href="#strings_and_stripped_strings">#</a>
          </h5>
          <p>If there’s more than one thing inside a tag, you can still look at just the strings. Use the <code class="inline-code">.strings</code> generator:</p>
          <pre><code class="python">for string in soup.strings:
    print(repr(string))
# u"The Dormouse's story"
# u'\n\n'
# u"The Dormouse's story"
# u'\n\n'
# u'Once upon a time there were three little sisters; and their names were\n'
# u'Elsie'
# u',\n'
# u'Lacie'
# u' and\n'
# u'Tillie'
# u';\nand they lived at the bottom of a well.'
# u'\n\n'
# u'...'
# u'\n'</code></pre>
          <p>These strings tend to have a lot of extra whitespace, which you can remove by using the <code class="inline-code">.stripped_strings</code> generator instead:</p>
          <pre><code class="python">for string in soup.stripped_strings:
    print(repr(string))
# u"The Dormouse's story"
# u"The Dormouse's story"
# u'Once upon a time there were three little sisters; and their names were'
# u'Elsie'
# u','
# u'Lacie'
# u'and'
# u'Tillie'
# u';\nand they lived at the bottom of a well.'
# u'...'</code></pre>
          <p>Here, strings consisting entirely of whitespace are ignored, and whitespace at the beginning and end of strings is removed.</p>

          <h4 class="sub-header" id="Going_Up">
            <span class="number sub-section-number">6.2</span>Going Up<a class="header-anchor" href="#Going_Up">#</a>
          </h4>
          <p>Continuing the “family tree” analogy, every tag and every string has a <i>parent</i>: the tag that contains it.</p>

          <h5 class="sub-header sub-header2" id="parent">
            <span class="number sub-section-number">6.2.1</span><code class="inline-code">.parent</code><a class="header-anchor" href="#parent">#</a>
          </h5>
          <p>You can access an element’s parent with the <code class="inline-code">.parent</code> attribute. In the example “three sisters” document, the <code class="inline-code">&lt;head></code> tag is the parent of the <code class="inline-code">&lt;title></code> tag:</p>
          <pre><code class="python">title_tag = soup.title
title_tag
# &lt;title&gt;The Dormouse's story&lt;/title&gt;
title_tag.parent
# &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</code></pre>
          <p>The title string itself has a parent: the <code class="inline-code">&lt;title></code> tag that contains it:</p>
          <pre><code class="python">title_tag.string.parent
# &lt;title>The Dormouse's story&lt;/title></code></pre>
          <p>The parent of a top-level tag like <code class="inline-code">&lt;html></code> is the <code class="inline-code">BeautifulSoup</code> object itself:</p>
          <pre><code class="python">html_tag = soup.html
type(html_tag.parent)
# &lt;class 'bs4.BeautifulSoup'></code></pre>
          <p>And the <code class="inline-code">.parent</code> of a <code class="inline-code">BeautifulSoup</code> object is defined as None:</p>
          <pre><code class="python">print(soup.parent)
# None</code></pre>

          <h5 class="sub-header sub-header2" id="parents">
            <span class="number sub-section-number">6.2.2</span><code class="inline-code">.parents</code> <a class="header-anchor" href="#parents">#</a>
          </h5>
          <p>You can iterate over all of an element’s parents with <code class="inline-code">.parents</code>. This example uses <code class="inline-code">.parents</code> to travel from an <code class="inline-code">&lt;a></code> tag buried deep within the document, to the very top of the document:</p>
          <pre><code class="python">link = soup.a
link
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;
for parent in link.parents:
    if parent is None:
        print(parent)
    else:
        print(parent.name)
# p
# body
# html
# [document]
# None</code></pre>

          <h4 class="sub-header" id="Going_Sideways">
            <span class="number sub-section-number">6.3</span>Going Sideways<a class="header-anchor" href="#Going_Sideways">#</a>
          </h4>
          <p>Consider a simple document like this:</p>
          <pre><code class="python">sibling_soup = BeautifulSoup(&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;)
print(sibling_soup.prettify())
# &lt;html&gt;
#  &lt;body&gt;
#   &lt;a&gt;
#    &lt;b&gt;
#     text1
#    &lt;/b&gt;
#    &lt;c&gt;
#     text2
#    &lt;/c&gt;
#   &lt;/a&gt;
#  &lt;/body&gt;
# &lt;/html&gt;
</code></pre>
          <p>The <code class="inline-code">&lt;b></code> tag and the <code class="inline-code">&lt;c></code> tag are at the same level: they’re both direct children of the same tag. We call them <i>siblings</i>. When a document is pretty-printed, siblings show up at the same indentation level. You can also use this relationship in the code you write.</p>

          <h5 class="sub-header sub-header2" id="next_sibling_and_previous_sibling">
            <span class="number sub-section-number">6.3.1</span><code class="inline-code">.next_sibling</code> and <code class="inline-code">.previous_sibling</code><a class="header-anchor" href="#next_sibling_and_previous_sibling">#</a>
          </h5>
          <p>You can use <code class="inline-code">.next_sibling</code> and <code class="inline-code">.previous_sibling</code> to navigate between page elements that are on the same level of the parse tree:</p>
          <pre><code class="python">sibling_soup.b.next_sibling
# &lt;c&gt;text2&lt;/c&gt;

sibling_soup.c.previous_sibling
# &lt;b&gt;text1&lt;/b&gt;</code></pre>
          <p>The <code class="inline-code">&lt;b></code> tag has a <code class="inline-code">.next_sibling</code>, but no <code class="inline-code">.previous_sibling</code>, because there’s nothing before the <code class="inline-code">&lt;b></code> tag on the same level of the tree. For the same reason, the <code class="inline-code">&lt;c></code> tag has a <code class="inline-code">.previous_sibling</code> but no <code class="inline-code">.next_sibling</code>:</p>
          <pre><code class="python">print(sibling_soup.b.previous_sibling)
# None
print(sibling_soup.c.next_sibling)
# None</code></pre>
          <p>The strings “text1” and “text2” are <i>not</i> siblings, because they don’t have the same parent:</p>
          <pre><code class="python">sibling_soup.b.string
# u'text1'

print(sibling_soup.b.string.next_sibling)
# None</code></pre>
          <p>In real documents, the <code class="inline-code">.next_sibling</code> and <code class="inline-code">.previous_sibling</code> of a tag will usually be a string containing whitespace. Going back to the “three sisters” document:</p>
          <pre><code class="html">&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;
&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;
&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;
</code></pre>
          <p>You might think that the <code class="inline-code">.next_sibling</code> of the first <code class="inline-code">&lt;a></code> tag would be the second <code class="inline-code">&lt;a></code> tag. But actually, it’s a string: the comma and newline that separate the first <code class="inline-code">&lt;a></code> tag from the second:</p>
          <pre><code class="python">link = soup.a
link
# &lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>

link.next_sibling
# u',\n'</code></pre>
          <p>The second <code class="inline-code">&lt;a></code> tag is actually the <code class="inline-code">.next_sibling</code> of the comma:</p>
          <pre><code class="python">link.next_sibling.next_sibling
# &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a></code></pre>

          <h5 class="sub-header sub-header2" id="next_siblings_and_previous_siblings">
            <span class="number sub-section-number">6.3.2</span><code class="inline-code">.next_siblings</code> and <code class="inline-code">.previous_siblings</code><a class="header-anchor" href="#next_siblings_and_previous_siblings">#</a>
          </h5>
          <p>You can iterate over a tag’s siblings with <code class="inline-code">.next_siblings</code> or <code class="inline-code">.previous_siblings</code>:</p>
          <pre><code class="python">for sibling in soup.a.next_siblings:
    print(repr(sibling))
# u',\n'
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;
# u' and\n'
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;
# u'; and they lived at the bottom of a well.'
# None

for sibling in soup.find(id=&quot;link3&quot;).previous_siblings:
    print(repr(sibling))
# ' and\n'
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;
# u',\n'
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;
# u'Once upon a time there were three little sisters; and their names were\n'
# None</code></pre>

          <h4 class="sub-header" id="Going_Back_And_Forth">
            <span class="number sub-section-number">6.4</span>Going back and forth<a class="header-anchor" href="#Going_Back_And_Forth">#</a>
          </h4>
          <p>Take a look at the beginning of the “three sisters” document:</p>
          <pre><code class="html">&lt;html>&lt;head>&lt;title>The Dormouse's story&lt;/title>&lt;/head>
&lt;p class="title">&lt;b>The Dormouse's story&lt;/b>&lt;/p></code></pre>
          <p>An HTML parser takes this string of characters and turns it into a series of events: “open an <code class="inline-code">&lt;html></code> tag”, “open a <code class="inline-code">&lt;head></code> tag”, “open a <code class="inline-code">&lt;title></code> tag”, “add a string”, “close the <code class="inline-code">&lt;title></code> tag”, “open a <code class="inline-code">&lt;p></code> tag”, and so on. Beautiful Soup offers tools for reconstructing the initial parse of the document.</p>

          <h5 class="sub-header sub-header2" id="next_element_and_previous_element">
            <span class="number sub-section-number">6.4.1</span><code class="inline-code">.next_element</code> and <code class="inline-code">.previous_element</code><a class="header-anchor" href="#next_element_and_previous_element">#</a>
          </h5>
          <p>The <code class="inline-code">.next_element</code> attribute of a string or tag points to whatever was parsed immediately afterwards. It might be the same as <code class="inline-code">.next_sibling</code>, but it’s usually drastically different.</p>
          <p>Here’s the final <code class="inline-code">&lt;a></code> tag in the “three sisters” document. Its <code class="inline-code">.next_sibling</code> is a string: the conclusion of the sentence that was interrupted by the start of the <code class="inline-code">&lt;a></code> tag.:</p>
          <pre><code class="python">last_a_tag = soup.find("a", id="link3")
last_a_tag
# &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>

last_a_tag.next_sibling
# '; and they lived at the bottom of a well.</code></pre>
          <p>But the <code class="inline-code">.next_element</code> of that <code class="inline-code">&lt;a></code> tag, the thing that was parsed immediately after the <code class="inline-code">&lt;a></code> tag, is not the rest of that sentence: it’s the word “Tillie”:</p>
          <pre><code class="python">last_a_tag.next_element
# u'Tillie'</code></pre>
          <p>That’s because in the original markup, the word “Tillie” appeared before that semicolon. The parser encountered an <code class="inline-code">&lt;a></code> tag, then the word “Tillie”, then the closing <code class="inline-code">&lt;/a></code> tag, then the semicolon and rest of the sentence. The semicolon is on the same level as the <code class="inline-code">&lt;a></code> tag, but the word “Tillie” was encountered first.</p>
          <p>The <code class="inline-code">.previous_element</code> attribute is the exact opposite of <code class="inline-code">.next_element</code>. It points to whatever element was parsed immediately before this one:</p>
          <pre><code class="python">last_a_tag.previous_element
# u' and\n'
last_a_tag.previous_element.next_element
# &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a></code></pre>

          <h5 class="sub-header sub-header2" id="next_elements_and_previous_elements">
            <span class="number sub-section-number">6.4.2</span><code class="inline-code">.next_elements</code> and <code class="inline-code">.previous_elements</code><a class="header-anchor" href="#next_elements_and_previous_elements">#</a>
          </h5>
          <p>You should get the idea by now. You can use these iterators to move forward or backward in the document as it was parsed:</p>
          <pre><code class="python">for element in last_a_tag.next_elements:
    print(repr(element))
# u'Tillie'
# u';\nand they lived at the bottom of a well.'
# u'\n\n'
# &lt;p class="story">...&lt;/p>
# u'...'
# u'\n'
# None</code></pre>
          
        </section>

        <section class="main-section" id="7Searching_the_tree#">
          <header><span class="number section-number">7</span>Searching the tree<a class="header-anchor" href="#7Searching_the_tree#">#</a></header>
          <p>Beautiful Soup defines a lot of methods for searching the parse tree, but they’re all very similar. I’m going to spend a lot of time explaining the two most popular methods: <code class="inline-code">find()</code> and <code class="inline-code">find_all()</code>. The other methods take almost exactly the same arguments, so I’ll just cover them briefly.</p>
          <p>Once again, I’ll be using the “three sisters” document as an example:</p>
          <pre><code class="python">html_doc = &quot;&quot;&quot;
&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
and they lived at the bottom of a well.&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;
&quot;&quot;&quot;

from bs4 import BeautifulSoup
soup = BeautifulSoup(html_doc, 'html.parser')</code></pre>
          <p>By passing in a filter to an argument like <code class="inline-code">find_all()</code>, you can zoom in on the parts of the document you’re interested in.</p>

          <h4 class="sub-header" id="Kinds_Of_Filters">
            <span class="number sub-section-number">7.1 </span>Kinds of filters<a class="header-anchor" href="#Kinds_Of_Filters">#</a>
          </h4>
          <p>Before talking in detail about <code class="inline-code">find_all()</code> and similar methods, I want to show examples of different filters you can pass into these methods. These filters show up again and again, throughout the search API. You can use them to filter based on a tag’s name, on its attributes, on the text of a string, or on some combination of these.</p>

          <h5 class="sub-header sub-header2" id="A_String">
            <span class="number sub-section-number">7.1.1</span>A string<a class="header-anchor" href="#A_String">#</a>
          </h5>
          <p>The simplest filter is a string. Pass a string to a search method and Beautiful Soup will perform a match against that exact string. This code finds all the <code class="inline-code">&lt;b></code> tags in the document:</p>
          <pre><code class="python">soup.find_all('b')
# [&lt;b>The Dormouse's story&lt;/b>]</code></pre>
          <p>If you pass in a byte string, Beautiful Soup will assume the string is encoded as UTF-8. You can avoid this by passing in a Unicode string instead.</p>

          <h5 class="sub-header sub-header2" id="A_Regular_Expression">
            <span class="number sub-section-number">7.1.2</span>A regular expression<a class="header-anchor" href="#A_Regular_Expression">#</a>
          </h5>
          <p>If you pass in a regular expression object, Beautiful Soup will filter against that regular expression using its <code class="inline-code">search()</code> method. This code finds all the tags whose names start with the letter “b”; in this case, the <code class="inline-code">&lt;body></code> tag and the <code class="inline-code">&lt;b></code> tag:</p>
          <pre><code class="python">import re
for tag in soup.find_all(re.compile("^b")):
    print(tag.name)
# body
# b
</code></pre>
          <p>This code finds all the tags whose names contain the letter ‘t’:</p>
          <pre><code class="python">for tag in soup.find_all(re.compile("t")):
    print(tag.name)
# html
# title</code></pre>

          <h5 class="sub-header sub-header2" id="A_List">
            <span class="number sub-section-number">7.1.1</span>A list<a class="header-anchor" href="#A_List">#</a>
          </h5>
          <p>If you pass in a list, Beautiful Soup will allow a string match against <i>any</i> item in that list. This code finds all the <code class="inline-code">&lt;a></code> tags and all the <code class="inline-code">&lt;b></code> tags:</p>
          <pre><code class="python">soup.find_all(["a", "b"])
# [&lt;b>The Dormouse's story&lt;/b>,
#  &lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>]</code></pre>

          <h5 class="sub-header sub-header2" id="True">
            <span class="number sub-section-number">7.1.2</span><code class="inline-code">True</code><a class="header-anchor" href="#True">#</a>
          </h5>
          <p>The value <code class="inline-code">True</code> matches everything it can. This code finds <i>all</i> the tags in the document, but none of the text strings:</p>
          <pre><code class="python">for tag in soup.find_all(True):
    print(tag.name)
# html
# head
# title
# body
# p
# b
# p
# a
# a
# a
# p</code></pre>

          <h5 class="sub-header sub-header2" id="A_Function">
            <span class="number sub-section-number">7.1.1</span>A function<a class="header-anchor" href="#A_Function">#</a>
          </h5>
          <p>If none of the other matches work for you, define a function that takes an element as its only argument. The function should return <code class="inline-code">True</code> if the argument matches, and <code class="inline-code">False</code> otherwise.</p>
          <p>Here’s a function that returns <code class="inline-code">True</code> if a tag defines the “class” attribute but doesn’t define the “id” attribute:</p>
          <pre><code class="python">def has_class_but_no_id(tag):
return tag.has_attr('class') and not tag.has_attr('id')</code></pre>
          <p>Pass this function into <code class="inline-code">find_all()</code> and you’ll pick up all the <code class="inline-code">&lt;p></code> tags:</p>
          <pre><code class="python">soup.find_all(has_class_but_no_id)
# [&lt;p class="title">&lt;b>The Dormouse's story&lt;/b>&lt;/p>,
#  &lt;p class="story">Once upon a time there were…bottom of a well.&lt;/p>,
#  &lt;p class="story">...&lt;/p>]</code></pre>
          <p>This function only picks up the <code class="inline-code">&lt;p></code> tags. It doesn’t pick up the <code class="inline-code">&lt;a></code> tags, because those tags define both “class” and “id”. It doesn’t pick up tags like <code class="inline-code">&lt;html></code> and <code class="inline-code">&lt;title></code>, because those tags don’t define “class”.</p>
          <p>If you pass in a function to filter on a specific attribute like <code class="inline-code">href</code>, the argument passed into the function will be the attribute value, not the whole tag. Here’s a function that finds all <code class="inline-code">a</code> tags whose <code class="inline-code">href</code> attribute <i>does not</i> match a regular expression:</p>
          <pre><code class="python">def not_lacie(href):
    return href and not re.compile("lacie").search(href)
soup.find_all(href=not_lacie)
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>]</code></pre>
          <p>The function can be as complicated as you need it to be. Here’s a function that returns <code class="inline-code">True</code> if a tag is surrounded by string objects:</p>
          <pre><code class="python">from bs4 import NavigableString
def surrounded_by_strings(tag):
    return (isinstance(tag.next_element, NavigableString)
            and isinstance(tag.previous_element, NavigableString))

for tag in soup.find_all(surrounded_by_strings):
    print tag.name
# p
# a
# a
# a
# p
</code></pre>
          <p>Now we’re ready to look at the search methods in detail.</p>

          <h4 class="sub-header" id="find_all">
            <span class="number sub-section-number">7.2 </span><code class="inline-code">find_all()</code><a class="header-anchor" href="#find_all">#</a>
          </h4>
          <p>Signature: find_all(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_recursive_Argument">recursive</a>, <a href="#The_string_Argument">string</a>, <a href="#The_limit_Argument">limit</a>, <a href="#The_Keyword_Argument">**kwargs</a>)</p>
          <p>The <code class="inline-code">find_all()</code> method looks through a tag’s descendants and retrieves <i>all</i> descendants that match your filters. I gave several examples in <a href="#Kinds_Of_Filters">Kinds of filters</a>, but here are a few more:</p>
          <pre><code class="python">soup.find_all(&quot;title&quot;)
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]

soup.find_all(&quot;p&quot;, &quot;title&quot;)
# [&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]

soup.find_all(&quot;a&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.find_all(id=&quot;link2&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]

import re
soup.find(string=re.compile(&quot;sisters&quot;))
# u'Once upon a time there were three little sisters; and their names were\n'</code></pre>
          <p>Some of these should look familiar, but others are new. What does it mean to pass in a value for <code class="inline-code">string</code>, or <code class="inline-code">id</code>? Why does <code class="inline-code">find_all("p", "title")</code> find a <code class="inline-code">&lt;p></code> tag with the CSS class “title”? Let’s look at the arguments to <code class="inline-code">find_all()</code>.</p>

          <h5 class="sub-header sub-header2" id="The_name_Argument">
            <span class="number sub-section-number">7.1.1</span>The <code class="inline-code">.name</code> Argument<a class="header-anchor" href="#The_name_Argument">#</a>
          </h5>
          <p>Pass in a value for <code class="inline-code">name</code> and you’ll tell Beautiful Soup to only consider tags with certain names. Text strings will be ignored, as will tags whose names that don’t match.</p>
          <p>This is the simplest usage:</p>
          <pre><code class="python">soup.find_all("title")
# [&lt;title>The Dormouse's story&lt;/title>]</code></pre>
          <p>Recall from <a href="#Kinds_Of_Filters">Kinds of filters</a> that the value to <code class="inline-code">.name</code> can be <a href="#A_String">a
            string</a>, <a href="#A_Regular_Expression">a regular expression</a>, <a href="#A_List">a list</a>, <a href="#A_Function">a function</a>, or <a href="#True">the value
            True</a>.</p>

          <h5 class="sub-header sub-header2" id="The_Keyword_Arguments">
            <span class="number sub-section-number">7.1.2</span>The Keyword Arguments<a class="header-anchor" href="#The_Keyword_Arguments">#</a>
          </h5>
          <p>Any argument that’s not recognized will be turned into a filter on one of a tag’s attributes. If you pass in a value for an argument called <code class="inline-code">id</code>, Beautiful Soup will filter against each tag’s ‘id’ attribute:</p>
          <pre><code class="python">soup.find_all(id='link2')
# [&lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>]</code></pre>
          <p>If you pass in a value for <code class="inline-code">href</code>, Beautiful Soup will filter against each tag’s ‘href’ attribute:</p>
          <pre><code class="python">soup.find_all(href=re.compile("elsie"))
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>]</code></pre>
          <p>You can filter an attribute based on <a href="#A_String">a
            string</a>, <a href="#A_Regular_Expression">a regular expression</a>, <a href="#A_List">a list</a>, <a href="#A_Function">a function</a>, or <a href="#True">the value
            True</a>.</p>
          <p>This code finds all tags whose <code class="inline-code">id</code> attribute has a value, regardless of what the value is:</p>
          <pre><code class="python">soup.find_all(id=True)
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>]</code></pre>
          <p>You can filter multiple attributes at once by passing in more than one keyword argument:</p>
          <pre><code class="python">soup.find_all(href=re.compile("elsie"), id='link1')
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">three&lt;/a>]</code></pre>
          <p>Some attributes, like the data-* attributes in HTML 5, have names that can’t be used as the names of keyword arguments:</p>
          <pre><code class="python">data_soup = BeautifulSoup('&lt;div data-foo="value">foo!&lt;/div>')
data_soup.find_all(data-foo="value")
# SyntaxError: keyword can't be an expression</code></pre>
          <p>You can use these attributes in searches by putting them into a dictionary and passing the dictionary into <code class="inline-code">find_all()</code> as the <code class="inline-code">attrs</code> argument:</p>
          <pre><code class="python">data_soup.find_all(attrs={"data-foo": "value"})
# [&lt;div data-foo="value">foo!&lt;/div>]</code></pre>
          <p>You can’t use a keyword argument to search for HTML’s ‘name’ element, because Beautiful Soup uses the <code class="inline-code">name</code> argument to contain the name of the tag itself. Instead, you can give a value to ‘name’ in the <code class="inline-code">attrs</code> argument:</p>
          <pre><code class="python">name_soup = BeautifulSoup('&lt;input name="email"/>')
name_soup.find_all(name="email")
# []
name_soup.find_all(attrs={"name": "email"})
# [&lt;input name="email"/>]</code></pre>

          <h5 class="sub-header sub-header2" id="Searching_By_CSS_Class">
            <span class="number sub-section-number">7.1.3</span>Searching by CSS class<a class="header-anchor" href="#Searching_By_CSS_Class">#</a>
          </h5>
          <p>It’s very useful to search for a tag that has a certain CSS class, but the name of the CSS attribute, “class”, is a reserved word in Python. Using <code class="inline-code">class</code> as a keyword argument will give you a syntax error. As of Beautiful Soup 4.1.2, you can search by CSS <code>class</code> using the keyword argument class_:</p>
          <pre><code class="python">soup.find_all("a", class_="sister")
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>]</code></pre>
          <p>As with any keyword argument, you can pass <code class="inline-code">class_</code> a string, a regular expression, a function, or <code class="inline-code">True</code>:</p>
          <pre><code class="python">soup.find_all(class_=re.compile("itl"))
# [&lt;p class="title">&lt;b>The Dormouse's story&lt;/b>&lt;/p>]

def has_six_characters(css_class):
    return css_class is not None and len(css_class) == 6

soup.find_all(class_=has_six_characters)
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>]</code></pre>
          <p><a href="#Multi_Valued_Attributes">Remember</a> that a single tag can have multiple values for its “class” attribute. When you search for a tag that matches a certain CSS class, you’re matching against any of its CSS classes:</p>
          <pre><code class="python">css_soup = BeautifulSoup('&lt;p class="body strikeout">&lt;/p>')
css_soup.find_all("p", class_="strikeout")
# [&lt;p class="body strikeout">&lt;/p>]

css_soup.find_all("p", class_="body")
# [&lt;p class="body strikeout">&lt;/p>]</code></pre>
          <p>You can also search for the exact string value of the <code class="inline-code">class</code> attribute:</p>
          <pre><code class="python">css_soup.find_all("p", class_="body strikeout")
# [&lt;p class="body strikeout">&lt;/p>]</code></pre>
          <p>But searching for variants of the string value won’t work:</p>
          <pre><code class="python">css_soup.find_all("p", class_="strikeout body")
# []</code></pre>
          <p>If you want to search for tags that match two or more CSS classes, you should use a CSS selector:</p>
          <pre><code class="python">css_soup.select("p.strikeout.body")
# [&lt;p class="body strikeout">&lt;/p>]</code></pre>
          <p>In older versions of Beautiful Soup, which don’t have the <code class="inline-code">class_</code> shortcut, you can use the <code class="inline-code">attrs</code> trick mentioned above. Create a dictionary whose value for “class” is the string (or regular expression, or whatever) you want to search for:</p>
          <pre><code class="python">soup.find_all("a", attrs={"class": "sister"})
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/tillie" id="link3">Tillie&lt;/a>]</code></pre>

          <h5 class="sub-header sub-header2" id="The_string_Argument">
            <span class="number sub-section-number">7.1.4</span>The <code class="inline-code">string</code> Argument<a class="header-anchor" href="#The_string_Argument">#</a>
          </h5>
          <p>With <code class="inline-code">string</code> you can search for strings instead of tags. As with <code class="inline-code">name</code> and the keyword arguments, you can pass in <a href="#A_String">a
            string</a>, <a href="#A_Regular_Expression">a regular expression</a>, <a href="#A_List">a list</a>, <a href="#A_Function">a function</a>, or <a href="#True">the value
            True</a>.Here are some examples:</p>
            <pre><code class="python">soup.find_all(string="Elsie")
# [u'Elsie']

soup.find_all(string=["Tillie", "Elsie", "Lacie"])
# [u'Elsie', u'Lacie', u'Tillie']

soup.find_all(string=re.compile("Dormouse"))
[u"The Dormouse's story", u"The Dormouse's story"]

def is_the_only_string_within_a_tag(s):
    """Return True if this string is the only child of its parent tag."""
    return (s == s.parent.string)

soup.find_all(string=is_the_only_string_within_a_tag)
# [u"The Dormouse's story", u"The Dormouse's story", u'Elsie', u'Lacie', u'Tillie', u'...']</code></pre>
            <p>Although <code class="inline-code">string</code> is for finding strings, you can combine it with arguments that find tags: Beautiful Soup will find all tags whose <code class="inline-code">.string</code> matches your value for <code class="inline-code">string</code>. This code finds the <code class="inline-code">&lt;a></code> tags whose <code class="inline-code">.string</code> is “Elsie”:</p>
            <pre><code class="python">soup.find_all("a", string="Elsie")
# [&lt;a href="http://example.com/elsie" class="sister" id="link1">Elsie&lt;/a>]</code></pre>
            <p>The <code class="inline-code">string</code> argument is new in Beautiful Soup 4.4.0. In earlier versions it was called <code class="inline-code">text</code>:</p>
            <pre><code class="python">soup.find_all("a", text="Elsie")
# [&lt;a href="http://example.com/elsie" class="sister" id="link1">Elsie&lt;/a>]</code></pre>

          <h5 class="sub-header sub-header2" id="The_limit_Argument">
            <span class="number sub-section-number">7.1.5</span>The <code class="inline-code">limit</code> Argument<a class="header-anchor" href="#The_limit_Argument">#</a>
          </h5>
          <p><code class="inline-code">find_all()</code> returns all the tags and strings that match your filters. This can take a while if the document is large. If you don’t need all the results, you can pass in a number for <code class="inline-code">limit</code>. This works just like the LIMIT keyword in SQL. It tells Beautiful Soup to stop gathering results after it’s found a certain number.</p>
          <p>There are three links in the “three sisters” document, but this code only finds the first two:</p>
          <pre><code class="python">soup.find_all("a", limit=2)
# [&lt;a class="sister" href="http://example.com/elsie" id="link1">Elsie&lt;/a>,
#  &lt;a class="sister" href="http://example.com/lacie" id="link2">Lacie&lt;/a>]</code></pre>

          <h5 class="sub-header sub-header2" id="The_recursive_Argument">
            <span class="number sub-section-number">7.1.6</span>The <code class="inline-code">recursive</code> Argument<a class="header-anchor" href="#The_recursive_Argument">#</a>
          </h5>
          <p>If you call <code class="inline-code">mytag.find_all()</code>, Beautiful Soup will examine all the descendants of <code class="inline-code">mytag</code>: its children, its children’s children, and so on. If you only want Beautiful Soup to consider direct children, you can pass in <code class="inline-code">recursive=False</code>. See the difference here:</p>
          <pre><code class="python">soup.html.find_all("title")
# [&lt;title>The Dormouse's story&lt;/title>]

soup.html.find_all("title", recursive=False)
# []</code></pre>
          <p>Here’s that part of the document:</p>
          <pre><code class="html">&lt;html>
 &lt;head>
  &lt;title>
   The Dormouse's story
  &lt;/title>
 &lt;/head>
...
</code></pre>
          <p>The <code class="inline-code">&lt;title></code> tag is beneath the <code class="inline-code">&lt;html></code> tag, but it’s not directly beneath the <code class="inline-code">&lt;html></code> tag: the <code class="inline-code">&lt;head></code> tag is in the way. Beautiful Soup finds the <code class="inline-code">&lt;title></code> tag when it’s allowed to look at all descendants of the <code class="inline-code">&lt;html></code> tag, but when <code class="inline-code">recursive=False</code> restricts it to the <code class="inline-code">&lt;html></code> tag’s immediate children, it finds nothing.</p>
          <p>Beautiful Soup offers a lot of tree-searching methods (covered below), and they mostly take the same arguments as <code class="inline-code">find_all()</code>: <code class="inline-code">name</code>, <code class="inline-code">attrs</code>, <code class="inline-code">string</code>, <code class="inline-code">limit</code>, and the keyword arguments. But the <code class="inline-code">recursive</code> argument is different: <code class="inline-code">find_all()</code> and <code class="inline-code">find()</code> are the only methods that support it. Passing <code class="inline-code">recursive=False</code> into a method like <code class="inline-code">find_parents()</code> wouldn’t be very useful.</p>

          <h4 class="sub-header" id="Calling_A_Tag_Is_Like_Calling_find_all">
            <span class="number sub-section-number">7.3 </span>Calling a tag is like calling <code class="inline-code">find_all()</code><a class="header-anchor" href="#Calling_A_Tag_Is_Like_Calling_find_all">#</a>
          </h4>
          <p>Because <code class="inline-code">find_all()</code> is the most popular method in the Beautiful Soup search API, you can use a shortcut for it. If you treat the <code class="inline-code">BeautifulSoup</code> object or a <code class="inline-code">Tag</code> object as though it were a function, then it’s the same as calling <code class="inline-code">find_all()</code> on that object. These two lines of code are equivalent:</p> 
          <pre><code class="python">soup.find_all(&quot;a&quot;)
soup(&quot;a&quot;)</code></pre>
          <p>These two lines are also equivalent:</p> 
          <pre><code class="python">soup.title.find_all(string=True)
soup.title(string=True)</code></pre>

          <h4 class="sub-header" id="find">
            <span class="number sub-section-number">7.4 </span><code class="inline-code">find()</code><a class="header-anchor" href="#find">#</a>
          </h4>
          <p>Signature: find(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_recursive_Argument">recursive</a>, <a href="#The_string_Argument">string</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>The <code class="inline-code">find_all()</code> method scans the entire document looking for results, but sometimes you only want to find one result. If you know a document only has one &lt;body&gt; tag, it’s a waste of time to scan the entire document looking for more. Rather than passing in <code class="inline-code">limit=1</code> every time you call <code class="inline-code">find_all</code>, you can use the <code class="inline-code">find()</code> method. These two lines of code are <i>nearly</i> equivalent:</p> 
          <pre><code class="python">soup.find_all('title', limit=1)
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]

soup.find('title')
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></code></pre> 
          <p>The only difference is that <code class="inline-code">find_all()</code> returns a list containing the single result, and <code class="inline-code">find()</code> just returns the result.</p> 
          <p>If <code class="inline-code">find_all()</code> can’t find anything, it returns an empty list. If <code class="inline-code">find()</code> can’t find anything, it returns <code class="inline-code">None</code>:</p> 
          <pre><code class="python">print(soup.find(&quot;nosuchtag&quot;))
# None</code></pre>
          <p>Remember the <code class="inline-code">soup.head.title</code> trick from <a href="#Navigating_Using_Tag_Names">Navigating using tag names</a>? That trick works by repeatedly calling <code class="inline-code">find()</code>:</p> 
          <pre><code class="python">soup.head.title
# &lt;title&gt;The Dormouse's story&lt;/title&gt;

soup.find(&quot;head&quot;).find(&quot;title&quot;)
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre> 

          <h4 class="sub-header" id="find_parents_and_find_parent">
            <span class="number sub-section-number">7.5 </span><code class="inline-code">find_parents()</code> and <code class="inline-code">find_parent()</code><a class="header-anchor" href="#find_parents_and_find_parent">#</a>
          </h4>
          <p>Signature: find_parents(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_limit_Argument">limit</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>Signature: find_parent(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>I spent a lot of time above covering <code class="inline-code">find_all()</code> and <code class="inline-code">find()</code>. The Beautiful Soup API defines ten other methods for searching the tree, but don’t be afraid. Five of these methods are basically the same as <code class="inline-code">find_all()</code>, and the other five are basically the same as <code class="inline-code">find()</code>. The only differences are in what parts of the tree they search.</p> 
          <p>First let’s consider <code class="inline-code">find_parents()</code> and <code class="inline-code">find_parent()</code>. Remember that <code class="inline-code">find_all()</code> and <code class="inline-code">find()</code> work their way down the tree, looking at tag’s descendants. These methods do the opposite: they work their way <i>up</i> the tree, looking at a tag’s (or a string’s) parents. Let’s try them out, starting from a string buried deep in the “three daughters” document:</p> 
          <pre><code class="python">a_string = soup.find(string=&quot;Lacie&quot;)
a_string
# u'Lacie'

a_string.find_parents(&quot;a&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]

a_string.find_parent(&quot;p&quot;)
# &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
#  and they lived at the bottom of a well.&lt;/p&gt;

a_string.find_parents(&quot;p&quot;, class=&quot;title&quot;)
# []</code></pre>
        <p>One of the three <code class="inline-code">&lt;a&gt;</code> tags is the direct parent of the string in question, so our search finds it. One of the three <code class="inline-code">&lt;p&gt;</code> tags is an indirect parent of the string, and our search finds that as well. There’s a <code class="inline-code">&lt;p&gt;</code> tag with the CSS class “title” <i>somewhere</i> in the document, but it’s not one of this string’s parents, so we can’t find it with <code class="inline-code">find_parents()</code>.</p>
        <p>You may have made the connection between <code class="inline-code">find_parent()</code> and <code class="inline-code">find_parents()</code>, and the <a href="#parent">.parent</a> and <a href="#parents">.parents</a> attributes mentioned earlier. The connection is very strong. These search methods actually use <code class="inline-code">.parents</code> to iterate over all the parents, and check each one against the provided filter to see if it matches.</p> 

          <h4 class="sub-header" id="find_next_siblings_and_find_next_sibling">
            <span class="number sub-section-number">7.6 </span><code class="inline-code">find_next_siblings()</code> and <code class="inline-code">find_next_sibling()</code><a class="header-anchor" href="#find_next_siblings_and_find_next_sibling">#</a>
          </h4>
          <p>Signature: find_next_siblings(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_limit_Argument">limit</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>Signature: find_next_sibling(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>These methods use <a href="#next_siblings_and_previous_siblings">.next_siblings</a> to iterate over the rest of an element’s siblings in the tree. The <code class="inline-code">find_next_siblings()</code> method returns all the siblings that match, and <code class="inline-code">find_next_sibling()</code> only returns the first one:</p> 
          <pre><code class="python">first_link = soup.a
first_link
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;

first_link.find_next_siblings(&quot;a&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

first_story_paragraph = soup.find(&quot;p&quot;, &quot;story&quot;)
first_story_paragraph.find_next_sibling(&quot;p&quot;)
# &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</code></pre>

          <h4 class="sub-header" id="find_previous_siblings_and_find_previous_sibling">
            <span class="number sub-section-number">7.7 </span><code class="inline-code">find_previous_siblings()</code> and <code class="inline-code">find_previous_sibling()</code><a class="header-anchor" href="#find_previous_siblings_and_find_previous_sibling">#</a>
          </h4>
          <p>Signature: find_previous_siblings(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_limit_Argument">limit</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>Signature: find_previous_sibling(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>These methods use <a href="#next_siblings_and_previous_siblings">.previous_siblings</a> to iterate over an element’s siblings that precede it in the tree. The <code class="inline-code">find_previous_siblings()</code> method returns all the siblings that match, and <code class="inline-code">find_previous_sibling()</code> only returns the first one:</p> 
          <pre><code class="python">last_link = soup.find(&quot;a&quot;, id=&quot;link3&quot;)
last_link
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;

last_link.find_previous_siblings(&quot;a&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]

first_story_paragraph = soup.find(&quot;p&quot;, &quot;story&quot;)
first_story_paragraph.find_previous_sibling(&quot;p&quot;)
# &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;</code></pre>

          <h4 class="sub-header" id="find_all_next_and_find_next">
            <span class="number sub-section-number">7.8 </span><code class="inline-code">find_all_next()</code> and <code class="inline-code">find_next()</code><a class="header-anchor" href="#find_all_next_and_find_next">#</a>
          </h4>
          <p>Signature: find_all_next(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_limit_Argument">limit</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>Signature: find_next(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>These methods use <a href="#next_element_and_previous_element">.next_elements</a> to iterate over whatever tags and strings that come after it in the document. The <code class="inline-code">find_all_next()</code> method returns all matches, and <code class="inline-code">find_next()</code> only returns the first match:</p> 
          <pre><code class="python">first_link = soup.a
first_link
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;

first_link.find_all_next(string=True)
# [u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',
#  u';\nand they lived at the bottom of a well.', u'\n\n', u'...', u'\n']

first_link.find_next(&quot;p&quot;)
# &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</code></pre>

          <h4 class="sub-header" id="find_all_previous_and_find_previous">
            <span class="number sub-section-number">7.9 </span><code class="inline-code">find_all_previous()</code> and <code class="inline-code">find_previous()</code><a class="header-anchor" href="#find_all_previous_and_find_previous">#</a>
          </h4>
          <p>Signature: find_all_previous(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_limit_Argument">limit</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>Signature: find_previous(<a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, <a href="#The_Keyword_Arguments">**kwargs</a>)</p> 
          <p>These methods use <a href="#next_element_and_previous_element">.previous_elements</a> to iterate over the tags and strings that came before it in the document. The <code class="inline-code">find_all_previous()</code> method returns all matches, and <code class="inline-code">find_previous()</code> only returns the first match:</p> 
          <pre><code class="python">first_link = soup.a
first_link
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;

first_link.find_all_previous(&quot;p&quot;)
# [&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; ...&lt;/p&gt;,
#  &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;]

first_link.find_previous(&quot;title&quot;)
# &lt;title&gt;The Dormouse's story&lt;/title&gt;</code></pre>
          <p>The call to <code class="inline-code">find_all_previous("p")</code> found the first paragraph in the document (the one with class=”title”), but it also finds the second paragraph, the <code class="inline-code">&lt;p&gt;</code> tag that contains the <code class="inline-code">&lt;a&gt;</code> tag we started with. This shouldn’t be too surprising: we’re looking at all the tags that show up earlier in the document than the one we started with. A <code class="inline-code">&lt;p&gt;</code> tag that contains an <code class="inline-code">&lt;a&gt;</code> tag must have shown up before the <code class="inline-code">&lt;a&gt;</code> tag it contains.</p>

          <h4 class="sub-header" id="CSS_Selectors">
            <span class="number sub-section-number">7.10 </span>CSS selectors<a class="header-anchor" href="#CSS_Selectors">#</a>
          </h4>
          <p>As of version 4.7.0, Beautiful Soup supports most CSS4 selectors via the <a href="https://facelessuser.github.io/soupsieve/">SoupSieve</a> project. If you installed Beautiful Soup through <code class="inline-code">pip</code>, SoupSieve was installed at the same time, so you don’t have to do anything extra.</p> 
          <p><code class="inline-code">BeautifulSoup</code> has a <code class="inline-code">.select()</code> method which uses SoupSieve to run a CSS selector against a parsed document and return all the matching elements. <code class="inline-code">Tag</code> has a similar method which runs a CSS selector against the contents of a single tag.</p> 
          <p>(Earlier versions of Beautiful Soup also have the <code class="inline-code">.select()</code> method, but only the most commonly-used CSS selectors are supported.)</p> 
          <p>The SoupSieve <a href="https://facelessuser.github.io/soupsieve/">documentation</a> lists all the currently supported CSS selectors, but here are some of the basics:</p> 
          <p>You can find tags:</p> 
          <pre><code class="python">soup.select(&quot;title&quot;)
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]

soup.select(&quot;p:nth-of-type(3)&quot;)
# [&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;]</code></pre> 
        <p>Find tags beneath other tags:</p> 
        <pre><code class="python">soup.select(&quot;body a&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.select(&quot;html head title&quot;)
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]</code></pre> 
         <p>Find tags <i>directly</i> beneath other tags:</p> 
         <pre><code class="python">soup.select(&quot;head &gt; title&quot;)
# [&lt;title&gt;The Dormouse's story&lt;/title&gt;]

soup.select(&quot;p &gt; a&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot;  id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.select(&quot;p &gt; a:nth-of-type(2)&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]

soup.select(&quot;p &gt;#link1&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]

soup.select(&quot;body &gt; a&quot;)
# []</code></pre> 
         <p>Find the siblings of tags:</p> 
         <pre><code class="python">soup.select(&quot;#link1 ~ .sister&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot;  id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.select(&quot;#link1 + .sister&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</code></pre> 
        <p>Find tags by CSS class:</p> 
        <pre><code class="python">soup.select(&quot;.sister&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.select(&quot;[class~=sister]&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</code></pre> 
        <p>Find tags by ID:</p> 
        <pre><code class="python">soup.select(&quot;#link1&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]

soup.select(&quot;a#link2&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</code></pre> 
        <p>Find tags that match any selector from a list of selectors:</p> 
        <pre><code class="python">soup.select(&quot;#link1,#link2&quot;)
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;]</code></pre> 
        <p>Test for the existence of an attribute:</p> 
        <pre><code class="python">soup.select('a[href]')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]</code></pre> 
        <p>Find tags by attribute value:</p> 
        <pre><code class="python">soup.select('a[href=&quot;http://example.com/elsie&quot;]')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]

soup.select('a[href^=&quot;http://example.com/&quot;]')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,
#  &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.select('a[href$=&quot;tillie&quot;]')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]

soup.select('a[href*=&quot;.com/el&quot;]')
# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;]</code></pre> 
         <p>There’s also a method called <code class="inline-code">select_one()</code>, which finds only the first tag that matches a selector:</p> 
         <pre><code class="python">soup.select_one(&quot;.sister&quot;)
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;</code></pre> 
         <p>If you’ve parsed XML that defines namespaces, you can use them in CSS selectors.:</p> 
         <pre><code class="python">from bs4 import BeautifulSoup
xml = &quot;&quot;&quot;&lt;tag xmlns:ns1=&quot;http://namespace1/&quot; xmlns:ns2=&quot;http://namespace2/&quot;&gt;
  &lt;ns1:child&gt;I'm in namespace 1&lt;/ns1:child&gt;
  &lt;ns2:child&gt;I'm in namespace 2&lt;/ns2:child&gt;
&lt;/tag&gt; &quot;&quot;&quot;
soup = BeautifulSoup(xml, &quot;xml&quot;)

soup.select(&quot;child&quot;)
# [&lt;ns1:child&gt;I'm in namespace 1&lt;/ns1:child&gt;, &lt;ns2:child&gt;I'm in namespace 2&lt;/ns2:child&gt;]

soup.select(&quot;ns1|child&quot;, namespaces=namespaces)
# [&lt;ns1:child&gt;I'm in namespace 1&lt;/ns1:child&gt;]</code></pre> 
         <p>When handling a CSS selector that uses namespaces, Beautiful Soup uses the namespace abbreviations it found when parsing the document. You can override this by passing in your own dictionary of abbreviations:</p> 
         <pre><code class="python">namespaces = dict(first=&quot;http://namespace1/&quot;, second=&quot;http://namespace2/&quot;)
soup.select(&quot;second|child&quot;, namespaces=namespaces)
# [&lt;ns1:child&gt;I'm in namespace 2&lt;/ns1:child&gt;]</code></pre> 
         <p>All this CSS selector stuff is a convenience for people who already know the CSS selector syntax. You can do all of this with the Beautiful Soup API. And if CSS selectors are all you need, you should parse the document with lxml: it’s a lot faster. But this lets you <i>combine</i> CSS selectors with the Beautiful Soup API.</p> 
  

        </section>

        <section class="main-section" id="8Modifying_the_tree#">
          <header><span class="number section-number">8</span>Modifying the tree<a class="header-anchor" href="#8Modifying_the_tree#">#</a></header>
          <p>Beautiful Soup’s main strength is in searching the parse tree, but you can also modify the tree and write your changes as a new HTML or XML document.</p>

          <h4 class="sub-header" id="Changing_Tag_Names_And_Attributes">
            <span class="number sub-section-number">8.1</span>Changing tag names and attributes<a class="header-anchor" href="#Changing_Tag_Names_And_Attributes">#</a>
          </h4>
          <p>I covered this earlier, in <a href="#Attributes">Attributes</a>, but it bears repeating. You can rename a tag, change the values of its attributes, add new attributes, and delete attributes:</p> 
          <pre><code class="python">soup = BeautifulSoup('&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;')
tag = soup.b

tag.name = &quot;blockquote&quot;
tag['class'] = 'verybold'
tag['id'] = 1
tag
# &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;

del tag['class']
del tag['id']
tag
# &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</code></pre>
 

          <h4 class="sub-header" id="Modifying_string">
            <span class="number sub-section-number">8.2 </span>Modifying <code class="inline-code">.string</code><a class="header-anchor" href="#Modifying_string">#</a>
          </h4>
          <p>If you set a tag’s <code class="inline-code">.string</code> attribute to a new string, the tag’s contents are replaced with that string:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)

tag = soup.a
tag.string = &quot;New link text.&quot;
tag
# &lt;a href=&quot;http://example.com/&quot;&gt;New link text.&lt;/a&gt;</code></pre>
          <p>Be careful: if the tag contained other tags, they and all their contents will be destroyed.</p> 

          <h4 class="sub-header" id="append">
            <span class="number sub-section-number">8.3 </span><code class="inline-code">append()</code><a class="header-anchor" href="#append">#</a>
          </h4>
          <p>You can add to a tag’s contents with <code class="inline-code">Tag.append()</code>. It works just like calling <code class="inline-code">.append()</code> on a Python list:</p> 
          <pre><code class="python">soup = BeautifulSoup(&quot;&lt;a&gt;Foo&lt;/a&gt;&quot;)
soup.a.append(&quot;Bar&quot;)

soup
# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;
soup.a.contents
# [u'Foo', u'Bar']</code></pre>

          <h4 class="sub-header" id="extend">
            <span class="number sub-section-number">8.4 </span><code class="inline-code">extend()</code><a class="header-anchor" href="#extend">#</a>
          </h4>
          <p>Starting in Beautiful Soup 4.7.0, <code class="inline-code">Tag</code> also supports a method called <code class="inline-code">.extend()</code>, which works just like calling <code class="inline-code">.extend()</code> on a Python list:</p> 
          <pre><code class="python">soup = BeautifulSoup(&quot;&lt;a&gt;Soup&lt;/a&gt;&quot;)
soup.a.extend([&quot;'s&quot;, &quot; &quot;, &quot;on&quot;])

soup
# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;Soup's on&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;
soup.a.contents
# [u'Soup', u''s', u' ', u'on']</code></pre> 

          <h4 class="sub-header" id="NavigableString_And_new_tag">
            <span class="number sub-section-number">8.5 </span><code class="inline-code">NavigableString()</code> and <code class="inline-code">.new_tag()</code><a class="header-anchor" href="#NavigableString_And_new_tag">#</a>
          </h4>
          <p>If you need to add a string to a document, no problem–you can pass a Python string in to <code class="inline-code">append()</code>, or you can call the <code class="inline-code">NavigableString</code> constructor:</p> 
          <pre><code class="python">soup = BeautifulSoup(&quot;&lt;b&gt;&lt;/b&gt;&quot;)
tag = soup.b
tag.append(&quot;Hello&quot;)
new_string = NavigableString(&quot; there&quot;)
tag.append(new_string)
tag
# &lt;b&gt;Hello there.&lt;/b&gt;
tag.contents
# [u'Hello', u' there']</code></pre> 
         <p>If you want to create a comment or some other subclass of <code class="inline-code">NavigableString</code>, just call the constructor:</p> 
         <pre><code class="python">from bs4 import Comment
new_comment = Comment(&quot;Nice to see you.&quot;)
tag.append(new_comment)
tag
# &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;
tag.contents
# [u'Hello', u' there', u'Nice to see you.']</code></pre> 
        <p>(This is a new feature in Beautiful Soup 4.4.0.)</p> 
        <p>What if you need to create a whole new tag? The best solution is to call the factory method <code class="inline-code">BeautifulSoup.new_tag()</code>:</p> 
        <pre><code class="python">soup = BeautifulSoup(&quot;&lt;b&gt;&lt;/b&gt;&quot;)
original_tag = soup.b

new_tag = soup.new_tag(&quot;a&quot;, href=&quot;http://www.example.com&quot;)
original_tag.append(new_tag)
original_tag
# &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;&lt;/a&gt;&lt;/b&gt;

new_tag.string = &quot;Link text.&quot;
original_tag
# &lt;b&gt;&lt;a href=&quot;http://www.example.com&quot;&gt;Link text.&lt;/a&gt;&lt;/b&gt;</code></pre> 
         <p>Only the first argument, the tag name, is required.</p> 

          <h4 class="sub-header" id="insert">
            <span class="number sub-section-number">8.6 </span><code class="inline-code">insert()</code><a class="header-anchor" href="#insert">#</a>
          </h4>
          <p><code class="inline-code">Tag.insert()</code> is just like <code class="inline-code">Tag.append()</code>, except the new element doesn’t necessarily go at the end of its parent’s <code class="inline-code">.contents</code>. It’ll be inserted at whatever numeric position you say. It works just like <code class="inline-code">.insert()</code> on a Python list:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
tag = soup.a

tag.insert(1, &quot;but did not endorse &quot;)
tag
# &lt;a href=&quot;http://example.com/&quot;&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;
tag.contents
# [u'I linked to ', u'but did not endorse', &lt;i&gt;example.com&lt;/i&gt;]</span></code></pre> 

          <h4 class="sub-header" id="insert_before_And_insert_after">
            <span class="number sub-section-number">8.7 </span><code class="inline-code">insert_before()</code> and <code class="inline-code">insert_after()</code><a class="header-anchor" href="#insert_before_And_insert_after">#</a>
          </h4>
          <p>The <code class="inline-code">insert_before()</code> method inserts tags or strings immediately before something else in the parse tree:</p> 
          <pre><code class="python">soup = BeautifulSoup(&quot;&lt;b&gt;stop&lt;/b&gt;&quot;)
tag = soup.new_tag(&quot;i&quot;)
tag.string = &quot;Don't&quot;
soup.b.string.insert_before(tag)
soup.b
# &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt;stop&lt;/b&gt;</code></pre> 
        <p>The <code class="inline-code">insert_after()</code> method inserts tags or strings immediately following something else in the parse tree:</p> 
        <pre><code class="python">div = soup.new_tag('div')
div.string = 'ever'
soup.b.i.insert_after(&quot; you &quot;, div)
soup.b
# &lt;b&gt;&lt;i&gt;Don't&lt;/i&gt; you &lt;div&gt;ever&lt;/div&gt; stop&lt;/b&gt;
soup.b.contents
# [&lt;i&gt;Don't&lt;/i&gt;, u' you', &lt;div&gt;ever&lt;/div&gt;, u'stop']</code></pre> 

          <h4 class="sub-header" id="clear">
            <span class="number sub-section-number">8.8 </span><code class="inline-code">clear()</code><a class="header-anchor" href="#clear">#</a>
          </h4>
          <p><code class="inline-code">Tag.clear()</code> removes the contents of a tag:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
tag = soup.a

tag.clear()
tag
# &lt;a href=&quot;http://example.com/&quot;&gt;&lt;/a&gt;</code></pre> 

          <h4 class="sub-header" id="extract">
            <span class="number sub-section-number">8.9 </span><code class="inline-code">extract()</code><a class="header-anchor" href="#extract">#</a>
          </h4>
          <p><code class="inline-code">PageElement.extract()</code> removes a tag or string from the tree. It returns the tag or string that was extracted:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
a_tag = soup.a

i_tag = soup.i.extract()

a_tag
# &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;

i_tag
# &lt;i&gt;example.com&lt;/i&gt;

print(i_tag.parent)
None</code></pre> 
         <p>At this point you effectively have two parse trees: one rooted at the <code class="inline-code">BeautifulSoup</code> object you used to parse the document, and one rooted at the tag that was extracted. You can go on to call <code class="inline-code">extract</code> on a child of the element you extracted:</p> 
         <pre><code class="python">my_string = i_tag.string.extract()
my_string
# u'example.com'

print(my_string.parent)
# None
i_tag
# &lt;i&gt;&lt;/i&gt;</code></pre>

          <h4 class="sub-header" id="decompose">
            <span class="number sub-section-number">8.10 </span><code class="inline-code">decompose</code><a class="header-anchor" href="#decompose">#</a>
          </h4>
          <p><code class="inline-code">Tag.decompose()</code> removes a tag from the tree, then <i>completely destroys it and its contents</i>:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
a_tag = soup.a

soup.i.decompose()

a_tag
# &lt;a href=&quot;http://example.com/&quot;&gt;I linked to&lt;/a&gt;</code></pre>

          <h4 class="sub-header" id="replace_with">
            <span class="number sub-section-number">8.11 </span><code class="inline-code">replace_with()</code><a class="header-anchor" href="#replace_with">#</a>
          </h4>
          <p><code class="inline-code">PageElement.replace_with()</code> removes a tag or string from the tree, and replaces it with the tag or string of your choice:</p>
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
a_tag = soup.a

new_tag = soup.new_tag(&quot;b&quot;)
new_tag.string = &quot;example.net&quot;
a_tag.i.replace_with(new_tag)

a_tag
# &lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;b&gt;example.net&lt;/b&gt;&lt;/a&gt;</code></pre>
          <p><code class="inline-code">replace_with()</code> returns the tag or string that was replaced, so that you can examine it or add it back to another part of the tree.</p>

          <h4 class="sub-header" id="wrap">
            <span class="number sub-section-number">8.12 </span><code class="inline-code">wrap()</code><a class="header-anchor" href="#wrap">#</a>
          </h4>
          <p><code class="inline-code">PageElement.wrap()</code> wraps an element in the tag you specify. It returns the new wrapper:</p> 
          <pre><code class="python">soup = BeautifulSoup(&quot;&lt;p&gt;I wish I was bold.&lt;/p&gt;&quot;)
soup.p.string.wrap(soup.new_tag(&quot;b&quot;))
# &lt;b&gt;I wish I was bold.&lt;/b&gt;

soup.p.wrap(soup.new_tag(&quot;div&quot;)
# &lt;div&gt;&lt;p&gt;&lt;b&gt;I wish I was bold.&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;</code></pre> 
        <p>This method is new in Beautiful Soup 4.0.5.</p> 

          <h4 class="sub-header" id="unwrap">
            <span class="number sub-section-number">8.13 </span><code class="inline-code">unwrap()</code><a class="header-anchor" href="#unwrap">#</a>
          </h4>
          <p><code class="inline-code">Tag.unwrap()</code> is the opposite of <code class="inline-code">wrap()</code>. It replaces a tag with whatever’s inside that tag. It’s good for stripping out markup:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
a_tag = soup.a

a_tag.i.unwrap()
a_tag
# &lt;a href=&quot;http://example.com/&quot;&gt;I linked to example.com&lt;/a&gt;</code></pre>
          <p>Like <code class="inline-code">replace_with()</code>, unwrap() returns the tag that was replaced.</p>

          <h4 class="sub-header" id="smooth">
            <span class="number sub-section-number">8.14 </span><code class="inline-code">smooth()</code><a class="header-anchor" href="#smooth">#</a>
          </h4>
          <p>After calling a bunch of methods that modify the parse tree, you may end up with two or more <code class="inline-code">NavigableString</code> objects next to each other. Beautiful Soup doesn’t have any problems with this, but since it can’t happen in a freshly parsed document, you might not expect behavior like the following:</p> 
          <pre><code class="python">soup = BeautifulSoup(&quot;&lt;p&gt;A one&lt;/p&gt;&quot;)
soup.p.append(&quot;, a two&quot;)

soup.p.contents
# [u'A one', u', a two']

print(soup.p.encode())
# &lt;p&gt;A one, a two&lt;/p&gt;

print(soup.p.prettify())
# &lt;p&gt;
#  A one
#  , a two
# &lt;/p&gt;</code></pre> 
        <p>You can call <code class="inline-code">Tag.smooth()</code> to clean up the parse tree by consolidating adjacent strings:</p> 
        <pre><code class="python">soup.smooth()

soup.p.contents
# [u'A one, a two']

print(soup.p.prettify())
# &lt;p&gt;
#  A one, a two
# &lt;/p&gt;</code></pre>
         <p>The <code class="inline-code">smooth()</code> method is new in Beautiful Soup 4.8.0.</p>

        </section>

        <section class="main-section" id="9Output#">
          <header><span class="number section-number">9</span>Output<a class="header-anchor" href="#9Output#">#</a></header>

          <h4 class="sub-header" id="Pretty_Printing">
            <span class="number sub-section-number">9.1</span>Pretty-printing<a class="header-anchor" href="#Pretty_Printing">#</a>
          </h4>
          <p>The <code class="inline-code">prettify()</code> method will turn a Beautiful Soup parse tree into a nicely formatted Unicode string, with a separate line for each tag and each string:</p>
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'
soup = BeautifulSoup(markup)
soup.prettify()
# '&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href=&quot;http://example.com/&quot;&gt;\n...'

print(soup.prettify())
# &lt;html&gt;
#  &lt;head&gt;
#  &lt;/head&gt;
#  &lt;body&gt;
#   &lt;a href=&quot;http://example.com/&quot;&gt;
#    I linked to
#    &lt;i&gt;
#     example.com
#    &lt;/i&gt;
#   &lt;/a&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre>
         <p>You can call <code class="inline-code">prettify()</code> on the top-level <code class="inline-code">BeautifulSoup</code> object, or on any of its <code class="inline-code">Tag</code> objects:</p> 
         <pre><code class="python">print(soup.a.prettify())
# &lt;a href=&quot;http://example.com/&quot;&gt;
#  I linked to
#  &lt;i&gt;
#   example.com
#  &lt;/i&gt;
# &lt;/a&gt;</code></pre>

          <h4 class="sub-header" id="Non_Pretty_Printing">
            <span class="number sub-section-number">9.2</span>Non-pretty printing<a class="header-anchor" href="#Non_Pretty_Printing">#</a>
          </h4>
          <p>If you just want a string, with no fancy formatting, you can call <code class="inline-code">unicode()</code> or <code class="inline-code">str()</code> on a <code class="inline-code">BeautifulSoup</code> object, or a <code class="inline-code">Tag</code> within it:</p> 
          <pre><code class="python">str(soup)
# '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'

unicode(soup.a)
# u'&lt;a href=&quot;http://example.com/&quot;&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</code></pre> 
         <p>The <code class="inline-code">str()</code> function returns a string encoded in UTF-8. See <a href="#11Encodings#">Encodings</a> for other options.</p> 
         <p>You can also call <code class="inline-code">encode()</code> to get a bytestring, and <code class="inline-code">decode()</code> to get Unicode.</p>

          <h4 class="sub-header" id="Output_Formatters">
            <span class="number sub-section-number">9.3</span>Output formatters<a class="header-anchor" href="#Output_Formatters">#</a>
          </h4>
          <p>If you give Beautiful Soup a document that contains HTML entities like “&amp;lquot;”, they’ll be converted to Unicode characters:</p>
          <pre><code class="python">soup = BeautifulSoup(&quot;&amp;ldquo;Dammit!&amp;rdquo; he said.&quot;)
unicode(soup)
# u'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\u201cDammit!\u201d he said.&lt;/body&gt;&lt;/html&gt;'</code></pre>
         <p>If you then convert the document to a string, the Unicode characters will be encoded as UTF-8. You won’t get the HTML entities back:</p> 
         <pre><code class="python">str(soup)
# '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;\xe2\x80\x9cDammit!\xe2\x80\x9d he said.&lt;/body&gt;&lt;/html&gt;'</code></pre> 
         <p>By default, the only characters that are escaped upon output are bare ampersands and angle brackets. These get turned into “&amp;amp;”, “&amp;lt;”, and “&amp;gt;”, so that Beautiful Soup doesn’t inadvertently generate invalid HTML or XML:</p> 
         <pre><code class="python">soup = BeautifulSoup(&quot;&lt;p&gt;The law firm of Dewey, Cheatem, &amp; Howe&lt;/p&gt;&quot;)
soup.p
# &lt;p&gt;The law firm of Dewey, Cheatem, &amp;amp; Howe&lt;/p&gt;

soup = BeautifulSoup('&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;')
soup.a
# &lt;a href=&quot;http://example.com/?foo=val1&amp;amp;bar=val2&quot;&gt;A link&lt;/a&gt;</code></pre> 
         <p>You can change this behavior by providing a value for the <code class="inline-code">formatter</code> argument to <code class="inline-code">prettify()</code>, <code class="inline-code">encode()</code>, or <code class="inline-code">decode()</code>. Beautiful Soup recognizes five possible values for <code class="inline-code">formatter</code>.</p> 
         <p>The default is <code class="inline-code">formatter=&quot;minimal&quot;</code>. Strings will only be processed enough to ensure that Beautiful Soup generates valid HTML/XML:</p> 
         <pre><code class="python">french = &quot;&lt;p&gt;Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;&lt;/p&gt;&quot;
soup = BeautifulSoup(french)
print(soup.prettify(formatter=&quot;minimal&quot;))
# &lt;html&gt;
#  &lt;body&gt;
#   &lt;p&gt;
#    Il a dit &amp;lt;&amp;lt;Sacr&eacute; bleu!&amp;gt;&amp;gt;
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre> 
         <p>If you pass in <code class="inline-code">formatter=&quot;html&quot;</code>, Beautiful Soup will convert Unicode characters to HTML entities whenever possible:</p> 
         <pre><code class="python">print(soup.prettify(formatter=&quot;html&quot;))
# &lt;html&gt;
#  &lt;body&gt;
#   &lt;p&gt;
#    Il a dit &amp;lt;&amp;lt;Sacr&amp;eacute; bleu!&amp;gt;&amp;gt;
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre> 
         <p>If you pass in <code class="inline-code">formatter=&quot;html5&quot;</code>, it’s the same as <code class="inline-code">formatter=&quot;html5&quot;</code>, but Beautiful Soup will omit the closing slash in HTML void tags like “br”:</p> 
         <pre><code class="python">soup = BeautifulSoup(&quot;&lt;br&gt;&quot;)
  
print(soup.encode(formatter=&quot;html&quot;))
# &lt;html&gt;&lt;body&gt;&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;

print(soup.encode(formatter=&quot;html5&quot;))
# &lt;html&gt;&lt;body&gt;&lt;br&gt;&lt;/body&gt;&lt;/html&gt;</code></pre> 
         <p>If you pass in <code class="inline-code">formatter=None</code>, Beautiful Soup will not modify strings at all on output. This is the fastest option, but it may lead to Beautiful Soup generating invalid HTML/XML, as in these examples:</p> 
         <pre><code class="python">print(soup.prettify(formatter=None))
# &lt;html&gt;
#  &lt;body&gt;
#   &lt;p&gt;
#    Il a dit &lt;&lt;Sacr&eacute; bleu!&gt;&gt;
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt;

link_soup = BeautifulSoup('&lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;')
print(link_soup.a.encode(formatter=None))
# &lt;a href=&quot;http://example.com/?foo=val1&amp;bar=val2&quot;&gt;A link&lt;/a&gt;</code></pre> 
         <p>If you need more sophisticated control over your output, you can use Beautiful Soup’s <code class="inline-code">Formatter</code> class. Here’s a formatter that converts strings to uppercase, whether they occur in a text node or in an attribute value:</p> 
         <pre><code class="python">from bs4.formatter import HTMLFormatter
def uppercase(str): 
    return str.upper()
formatter = HTMLFormatter(uppercase)

print(soup.prettify(formatter=formatter))
# &lt;html&gt;
#  &lt;body&gt;
#   &lt;p&gt;
#    IL A DIT &lt;&lt;SACR&Eacute; BLEU!&gt;&gt;
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt; 

print(link_soup.a.prettify(formatter=formatter))
# &lt;a href=&quot;HTTP://EXAMPLE.COM/?FOO=VAL1&amp;BAR=VAL2&quot;&gt;
#  A LINK
# &lt;/a&gt;</code></pre> 
         <p>Subclassing <code class="inline-code">HTMLFormatter</code> or <code class="inline-code">XMLFormatter</code> will give you even more control over the output. For example, Beautiful Soup sorts the attributes in every tag by default:</p> 
         <pre><code class="python">attr_soup = BeautifulSoup(b'&lt;p z=&quot;1&quot; m=&quot;2&quot; a=&quot;3&quot;&gt;&lt;/p&gt;')
print(attr_soup.p.encode())
# &lt;p a=&quot;3&quot; m=&quot;2&quot; z=&quot;1&quot;&gt;&lt;/p&gt;</code></pre> 
         <p>To turn this off, you can subclass the <code class="inline-code">Formatter.attributes()</code> method, which controls which attributes are output and in what order. This implementation also filters out the attribute called “m” whenever it appears:</p> 
         <pre><code class="python">class UnsortedAttributes(HTMLFormatter):
    def attributes(self, tag):
        for k, v in tag.attrs.items():
            if k == 'm':
                continue
            yield k, v
print(attr_soup.p.encode(formatter=UnsortedAttributes()))
# &lt;p z=&quot;1&quot; a=&quot;3&quot;&gt;&lt;/p&gt;</code></pre>
         <p>One last caveat: if you create a <code class="inline-code">CData</code> object, the text inside that object is always presented <i>exactly as it appears, with no formatting</i>. Beautiful Soup will call your entity substitution function, just in case you’ve written a custom function that counts all the strings in the document or something, but it will ignore the return value:</p> 
         <pre><code class="python">from bs4.element import CData
soup = BeautifulSoup(&quot;&lt;a&gt;&lt;/a&gt;&quot;)
soup.a.string = CData(&quot;one &lt; three&quot;)
print(soup.a.prettify(formatter=&quot;xml&quot;))
# &lt;a&gt;
#  &lt;![CDATA[one &lt; three]]&gt;
# &lt;/a&gt;</code></pre>

          <h4 class="sub-header" id="get_text">
            <span class="number sub-section-number">9.4</span><code class="inline-code">get_text()</code><a class="header-anchor" href="#get_text">#</a>
          </h4>
          <p>If you only want the text part of a document or tag, you can use the <code class="inline-code">get_text()</code> method. It returns all the text in a document or beneath a tag, as a single Unicode string:</p> 
          <pre><code class="python">markup = '&lt;a href=&quot;http://example.com/&quot;&gt;\nI linked to &lt;i&gt;example.com&lt;/i&gt;\n&lt;/a&gt;'
soup = BeautifulSoup(markup)

soup.get_text()
u'\nI linked to example.com\n'
soup.i.get_text()
u'example.com'</code></pre>
         <p>You can specify a string to be used to join the bits of text together:</p> 
         <pre><code class="python"># soup.get_text(&quot;|&quot;)
u'\nI linked to |example.com|\n'</code></pre> 
         <p>You can tell Beautiful Soup to strip whitespace from the beginning and end of each bit of text:</p> 
         <pre><code class="python"># soup.get_text(&quot;|&quot;, strip=True)
u'I linked to|example.com'</code></pre> 
         <p>But at that point you might want to use the <a href="#strings_and_stripped_strings">.stripped_strings</a> generator instead, and process the text yourself:</p> 
         <pre><code class="python">[text for text in soup.stripped_strings]
# [u'I linked to', u'example.com']</code></pre> 

        </section>

        <section class="main-section" id="10Specifying_the_parser_to_use#">
          <header><span class="number section-number">10</span>Specifying the parser to use<a class="header-anchor" href="#10Specifying_the_parser_to_use#">#</a></header>
          <p>If you just need to parse some HTML, you can dump the markup into the <code class="inline-code">BeautifulSoup</code> constructor, and it’ll probably be fine. Beautiful Soup will pick a parser for you and parse the data. But there are a few additional arguments you can pass in to the constructor to change which parser is used.</p> 
          <p>The first argument to the <code class="inline-code">BeautifulSoup</code> constructor is a string or an open filehandle–the markup you want parsed. The second argument is <i>how</i> you’d like the markup parsed.</p> 
          <p>If you don’t specify anything, you’ll get the best HTML parser that’s installed. Beautiful Soup ranks lxml’s parser as being the best, then html5lib’s, then Python’s built-in parser. You can override this by specifying one of the following:</p> 
          <ul> 
           <li>What type of markup you want to parse. Currently supported are “html”, “xml”, and “html5”.</li> 
           <li>The name of the parser library you want to use. Currently supported options are “lxml”, “html5lib”, and “html.parser” (Python’s built-in HTML parser).</li> 
          </ul> 
          <p>The section <a href="#Installing_A_Parser">Installing a parser</a> contrasts the supported parsers.</p> 
          <p>If you don’t have an appropriate parser installed, Beautiful Soup will ignore your request and pick a different parser. Right now, the only supported XML parser is lxml. If you don’t have lxml installed, asking for an XML parser won’t give you one, and asking for “lxml” won’t work either.</p>   

          <h4 class="sub-header" id="Differences_Between_Parsers">
            <span class="number sub-section-number">10.1</span>Differences between parsers<a class="header-anchor" href="#Differences_Between_Parsers">#</a>
          </h4>
          <p>Beautiful Soup presents the same interface to a number of different parsers, but each parser is different. Different parsers will create different parse trees from the same document. The biggest differences are between the HTML parsers and the XML parsers. Here’s a short document, parsed as HTML:</p> 
          <pre><code class="python">BeautifulSoup(&quot;&lt;a&gt;&lt;b /&gt;&lt;/a&gt;&quot;)
# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre> 
        <p>Since an empty <code class="inline-code">&lt;b /&gt;</code> tag is not valid HTML, the parser turns it into a <code class="inline-code">&lt;b&gt;&lt;/b&gt;</code> tag pair.</p> 
        <p>Here’s the same document parsed as XML (running this requires that you have lxml installed). Note that the empty <code class="inline-code">&lt;b /&gt;</code> tag is left alone, and that the document is given an XML declaration instead of being put into an <code class="inline-code">&lt;html&gt;</code> tag.:</p> 
        <pre><code class="python">BeautifulSoup(&quot;&lt;a&gt;&lt;b /&gt;&lt;/a&gt;&quot;, &quot;xml&quot;)
# &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
# &lt;a&gt;&lt;b/&gt;&lt;/a&gt;</code></pre> 
        <p>There are also differences between HTML parsers. If you give Beautiful Soup a perfectly-formed HTML document, these differences won’t matter. One parser will be faster than another, but they’ll all give you a data structure that looks exactly like the original HTML document.</p> 
        <p>But if the document is not perfectly-formed, different parsers will give different results. Here’s a short, invalid document parsed using lxml’s HTML parser. Note that the dangling <code class="inline-code">&lt;/p&gt;</code> tag is simply ignored:</p> 
        <pre><code class="python">BeautifulSoup(&quot;&lt;a&gt;&lt;/p&gt;&quot;, &quot;lxml&quot;)
# &lt;html&gt;&lt;body&gt;&lt;a&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre> 
        <p>Here’s the same document parsed using html5lib:</p> 
        <pre><code class="python">BeautifulSoup(&quot;&lt;a&gt;&lt;/p&gt;&quot;, &quot;html5lib&quot;)
# &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;&lt;p&gt;&lt;/p&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre> 
        <p>Instead of ignoring the dangling <code class="inline-code">&lt;/p&gt;</code> tag, html5lib pairs it with an opening <code class="inline-code">&lt;p&gt;</code> tag. This parser also adds an empty <code class="inline-code">&lt;head&gt;</code> tag to the document.</p> 
        <p>Here’s the same document parsed with Python’s built-in HTML parser:</p> 
        <pre><code class="python">BeautifulSoup(&quot;&lt;a&gt;&lt;/p&gt;&quot;, &quot;html.parser&quot;)
# &lt;a&gt;&lt;/a&gt;</code></pre> 
        <p>Like html5lib, this parser ignores the closing <code class="inline-code">&lt;/p&gt;</code> tag. Unlike html5lib, this parser makes no attempt to create a well-formed HTML document by adding a <code class="inline-code">&lt;body&gt;</code> tag. Unlike lxml, it doesn’t even bother to add an &lt;html&gt; tag.</p> 
        <p>Since the document “<code class="inline-code">&lt;a&gt;&lt;/p&gt;</code>” is invalid, none of these techniques is the “correct” way to handle it. The html5lib parser uses techniques that are part of the HTML5 standard, so it has the best claim on being the “correct” way, but all three techniques are legitimate.</p> 
        <p>Differences between parsers can affect your script. If you’re planning on distributing your script to other people, or running it on multiple machines, you should specify a parser in the <code class="inline-code">BeautifulSoup</code> constructor. That will reduce the chances that your users parse a document differently from the way you parse it.</p> 
 

        </section>

        <section class="main-section" id="11Encodings#">
          <header><span class="number section-number">11</span>Encodings<a class="header-anchor" href="#11Encodings#">#</a></header>
          <p>Any HTML or XML document is written in a specific encoding like ASCII or UTF-8. But when you load that document into Beautiful Soup, you’ll discover it’s been converted to Unicode:</p> 
          <pre><code class="python">markup = &quot;&lt;h1&gt;Sacr\xc3\xa9 bleu!&lt;/h1&gt;&quot;
soup = BeautifulSoup(markup)
soup.h1
# &lt;h1&gt;Sacr&eacute; bleu!&lt;/h1&gt;
soup.h1.string
# u'Sacr\xe9 bleu!'</code></pre> 
          <p>It’s not magic. (That sure would be nice.) Beautiful Soup uses a sub-library called <a href="#Unicode_Dammit">Unicode, Dammit</a> to detect a document’s encoding and convert it to Unicode. The autodetected encoding is available as the <code class="inline-code">.original_encoding</code> attribute of the <code class="inline-code">BeautifulSoup</code> object:</p> 
            <pre><code class="python">soup.original_encoding
'utf-8'</code></pre> 
            <p>Unicode, Dammit guesses correctly most of the time, but sometimes it makes mistakes. Sometimes it guesses correctly, but only after a byte-by-byte search of the document that takes a very long time. If you happen to know a document’s encoding ahead of time, you can avoid mistakes and delays by passing it to the <code class="inline-code">BeautifulSoup</code> constructor as <code class="inline-code">from_encoding</code>.</p> 
            <p>Here’s a document written in ISO-8859-8. The document is so short that Unicode, Dammit can’t get a lock on it, and misidentifies it as ISO-8859-7:</p> 
            <pre><code class="python">markup = b&quot;&lt;h1&gt;\xed\xe5\xec\xf9&lt;/h1&gt;&quot;
soup = BeautifulSoup(markup)
soup.h1
&lt;h1&gt;νεμω&lt;/h1&gt;
soup.original_encoding
'ISO-8859-7'</code></pre> 
              <p>We can fix this by passing in the correct <code class="inline-code">from_encoding</code>:</p>
              <pre><code class="python">soup = BeautifulSoup(markup, from_encoding=&quot;iso-8859-8&quot;)
soup.h1
&lt;h1&gt;םולש&lt;/h1&gt;
soup.original_encoding
'iso8859-8'</code></pre> 
                <p>If you don’t know what the correct encoding is, but you know that Unicode, Dammit is guessing wrong, you can pass the wrong guesses in as <code class="inline-code">exclude_encodings</code>:</p> 
                <pre><code class="python">soup = BeautifulSoup(markup, exclude_encodings=[&quot;ISO-8859-7&quot;])
soup.h1
&lt;h1&gt;םולש&lt;/h1&gt;
soup.original_encoding
'WINDOWS-1255'</code></pre> 
                  <p>Windows-1255 isn’t 100% correct, but that encoding is a compatible superset of ISO-8859-8, so it’s close enough. (<code class="inline-code">exclude_encodings</code> is a new feature in Beautiful Soup 4.4.0.)</p> 
                  <p>In rare cases (usually when a UTF-8 document contains text written in a completely different encoding), the only way to get Unicode may be to replace some characters with the special Unicode character “REPLACEMENT CHARACTER” (U+FFFD, �). If Unicode, Dammit needs to do this, it will set the <code class="inline-code">.contains_replacement_characters</code> attribute to <code class="inline-code">True</code> on the <code class="inline-code">UnicodeDammit</code> or <code class="inline-code">BeautifulSoup</code> object. This lets you know that the Unicode representation is not an exact representation of the original–some data was lost. If a document contains �, but <code class="inline-code">.contains_replacement_characters</code> is <code class="inline-code">False</code>, you’ll know that the � was there originally (as it is in this paragraph) and doesn’t stand in for missing data.</p> 


          <h4 class="sub-header" id="Output_Encoding">
            <span class="number sub-section-number">11.1</span>Output encoding<a class="header-anchor" href="#Output_Encoding">#</a>
          </h4>
          <p>When you write out a document from Beautiful Soup, you get a UTF-8 document, even if the document wasn’t in UTF-8 to begin with. Here’s a document written in the Latin-1 encoding:</p> 
          <pre><code class="python">markup = b'''
&lt;html&gt;
  &lt;head&gt;
  &lt;meta content=&quot;text/html; charset=ISO-Latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
'''

soup = BeautifulSoup(markup)
print(soup.prettify())
# &lt;html&gt;
#  &lt;head&gt;
#   &lt;meta content=&quot;text/html; charset=utf-8&quot; http-equiv=&quot;Content-type&quot; /&gt;
#  &lt;/head&gt;
#  &lt;body&gt;
#   &lt;p&gt;
#    Sacr&eacute; bleu!
#   &lt;/p&gt;
#  &lt;/body&gt;
# &lt;/html&gt;</code></pre>
          <p>Note that the <code class="inline-code">&lt;meta&gt;</code> tag has been rewritten to reflect the fact that the document is now in UTF-8.</p> 
          <p>If you don’t want UTF-8, you can pass an encoding into <code class="inline-code">prettify()</code>:</p> 
          <pre><code class="python">print(soup.prettify(&quot;latin-1&quot;))
# &lt;html&gt;
#  &lt;head&gt;
#   &lt;meta content=&quot;text/html; charset=latin-1&quot; http-equiv=&quot;Content-type&quot; /&gt;
# ...</code></pre> 
          <p>You can also call encode() on the <code class="inline-code">BeautifulSoup</code> object, or any element in the soup, just as if it were a Python string:</p> 
          <pre><code class="python">soup.p.encode(&quot;latin-1&quot;)
# '&lt;p&gt;Sacr\xe9 bleu!&lt;/p&gt;'

soup.p.encode(&quot;utf-8&quot;)
# '&lt;p&gt;Sacr\xc3\xa9 bleu!&lt;/p&gt;'</code></pre> 
          <p>Any characters that can’t be represented in your chosen encoding will be converted into numeric XML entity references. Here’s a document that includes the Unicode character SNOWMAN:</p> 
          <pre><code class="python">markup = u&quot;&lt;b&gt;\N{SNOWMAN}&lt;/b&gt;&quot;
snowman_soup = BeautifulSoup(markup)
tag = snowman_soup.b</code></pre> 
          <p>The SNOWMAN character can be part of a UTF-8 document (it looks like ☃), but there’s no representation for that character in ISO-Latin-1 or ASCII, so it’s converted into “&amp;#9731” for those encodings:</p> 
          <pre><code class="python">print(tag.encode(&quot;utf-8&quot;))
# &lt;b&gt;☃&lt;/b&gt;

print tag.encode(&quot;latin-1&quot;)
# &lt;b&gt;&amp;#9731;&lt;/b&gt;

print tag.encode(&quot;ascii&quot;)
# &lt;b&gt;&amp;#9731;&lt;/b&gt;</code></pre>

          <h4 class="sub-header" id="Unicode_Dammit">
            <span class="number sub-section-number">11.2</span>Unicode, Dammit<a class="header-anchor" href="#Unicode_Dammit">#</a>
          </h4>
          <p>You can use Unicode, Dammit without using Beautiful Soup. It’s useful whenever you have data in an unknown encoding and you just want it to become Unicode:</p> 
          <pre><code class="python">from bs4 import UnicodeDammit
dammit = UnicodeDammit(&quot;Sacr\xc3\xa9 bleu!&quot;)
print(dammit.unicode_markup)
# Sacr&eacute; bleu!
dammit.original_encoding
# 'utf-8'</code></pre> 
         <p>Unicode, Dammit’s guesses will get a lot more accurate if you install the <code class="inline-code">chardet</code> or <code class="inline-code">cchardet</code> Python libraries. The more data you give Unicode, Dammit, the more accurately it will guess. If you have your own suspicions as to what the encoding might be, you can pass them in as a list:</p> 
         <pre><code class="python">dammit = UnicodeDammit(&quot;Sacr\xe9 bleu!&quot;, [&quot;latin-1&quot;, &quot;iso-8859-1&quot;])
print(dammit.unicode_markup)
# Sacr&eacute; bleu!
dammit.original_encoding
# 'latin-1'</code></pre>
         <p>Unicode, Dammit has two special features that Beautiful Soup doesn’t use.</p> 

          <h5 class="sub-header sub-header2" id="Smart_Quotes">
            <span class="number sub-section-number">11.2.1</span>Smart quotes<a class="header-anchor" href="#Smart_Quotes">#</a>
          </h5>
          <p>You can use Unicode, Dammit to convert Microsoft smart quotes to HTML or XML entities:</p>
          <pre><code class="python">markup = b&quot;&lt;p&gt;I just \x93love\x94 Microsoft Word\x92s smart quotes&lt;/p&gt;&quot;

UnicodeDammit(markup, [&quot;windows-1252&quot;], smart_quotes_to=&quot;html&quot;).unicode_markup
# u'&lt;p&gt;I just &amp;ldquo;love&amp;rdquo; Microsoft Word&amp;rsquo;s smart quotes&lt;/p&gt;'

UnicodeDammit(markup, [&quot;windows-1252&quot;], smart_quotes_to=&quot;xml&quot;).unicode_markup
# u'&lt;p&gt;I just &amp;#x201C;love&amp;#x201D; Microsoft Word&amp;#x2019;s smart quotes&lt;/p&gt;'</code></pre>
          <p>You can also convert Microsoft smart quotes to ASCII quotes:</p> 
          <pre><code class="python">UnicodeDammit(markup, [&quot;windows-1252&quot;], smart_quotes_to=&quot;ascii&quot;).unicode_markup
   # u'&lt;p&gt;I just &quot;love&quot; Microsoft Word\'s smart quotes&lt;/p&gt;'</code></pre> 
          <p>Hopefully you’ll find this feature useful, but Beautiful Soup doesn’t use it. Beautiful Soup prefers the default behavior, which is to convert Microsoft smart quotes to Unicode characters along with everything else:</p> 
          <pre><code class="python">UnicodeDammit(markup, [&quot;windows-1252&quot;]).unicode_markup
   # u'&lt;p&gt;I just \u201clove\u201d Microsoft Word\u2019s smart quotes&lt;/p&gt;'</code></pre> 

          <h5 class="sub-header sub-header2" id="Inconsistent_Encodings">
            <span class="number sub-section-number">11.2.2</span>Inconsistent encodings<a class="header-anchor" href="#Inconsistent_Encodings">#</a>
          </h5>
          <p>Sometimes a document is mostly in UTF-8, but contains Windows-1252 characters such as (again) Microsoft smart quotes. This can happen when a website includes data from multiple sources. You can use <code class="inline-code">UnicodeDammit.detwingle()</code> to turn such a document into pure UTF-8. Here’s a simple example:</p>
          <pre><code class="python">snowmen = (u&quot;\N{SNOWMAN}&quot; * 3)
quote = (u&quot;\N{LEFT DOUBLE QUOTATION MARK}I like snowmen!\N{RIGHT DOUBLE QUOTATION MARK}&quot;)
doc = snowmen.encode(&quot;utf8&quot;) + quote.encode(&quot;windows_1252&quot;)</code></pre>
          <p>This document is a mess. The snowmen are in UTF-8 and the quotes are in Windows-1252. You can display the snowmen or the quotes, but not both:</p> 
          <pre><code class="python">print(doc)
# ☃☃☃�I like snowmen!�

print(doc.decode(&quot;windows-1252&quot;))
# &acirc;˜ƒ&acirc;˜ƒ&acirc;˜ƒ“I like snowmen!”</code></pre> 
          <p>Decoding the document as UTF-8 raises a <code class="inline-code">UnicodeDecodeError</code>, and decoding it as Windows-1252 gives you gibberish. Fortunately, <code class="inline-code">UnicodeDammit.detwingle()</code> will convert the string to pure UTF-8, allowing you to decode it to Unicode and display the snowmen and quote marks simultaneously:</p> 
          <pre><code class="python">new_doc = UnicodeDammit.detwingle(doc)
print(new_doc.decode(&quot;utf8&quot;))
# ☃☃☃“I like snowmen!”</code></pre> 
          <p><code class="inline-code">UnicodeDammit.detwingle()</code> only knows how to handle Windows-1252 embedded in UTF-8 (or vice versa, I suppose), but this is the most common case.</p> 
          <p>Note that you must know to call <code class="inline-code">UnicodeDammit.detwingle()</code> on your data before passing it into <code class="inline-code">BeautifulSoup</code> or the <code class="inline-code">UnicodeDammit</code> constructor. Beautiful Soup assumes that a document has a single encoding, whatever it might be. If you pass it a document that contains both UTF-8 and Windows-1252, it’s likely to think the whole document is Windows-1252, and the document will come out looking like <code class="inline-code">&acirc;˜ƒ&acirc;˜ƒ&acirc;˜ƒ“I like snowmen!”</code>.</p> 
          <p><code class="inline-code">UnicodeDammit.detwingle()</code> is new in Beautiful Soup 4.1.0.</p>

        </section>

        <section class="main-section" id="12Line_numbers#">
          <header><span class="number section-number">12</span>Line numbers<a class="header-anchor" href="#12Line_numbers#">#</a></header>
          <p>The <code class="inline-code">html.parser` and ``html5lib</code> parsers can keep track of where in the original document each Tag was found. You can access this information as <code class="inline-code">Tag.sourceline</code> (line number) and <code class="inline-code">Tag.sourcepos</code> (position of the start tag within a line):</p> 
            <pre><code class="python">markup = &quot;&lt;p\n&gt;Paragraph 1&lt;/p&gt;\n    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;
soup = BeautifulSoup(markup, 'html.parser')
for tag in soup.find_all('p'):
    print(tag.sourceline, tag.sourcepos, tag.string)
# (1, 0, u'Paragraph 1')
# (2, 3, u'Paragraph 2')</code></pre> 
            <p>Note that the two parsers mean slightly different things by <code class="inline-code">sourceline</code> and <code class="inline-code">sourcepos</code>. For html.parser, these numbers represent the position of the initial less-than sign. For html5lib, these numbers represent the position of the final greater-than sign:</p> 
              <pre><code class="python">soup = BeautifulSoup(markup, 'html5lib')
for tag in soup.find_all('p'):
    print(tag.sourceline, tag.sourcepos, tag.string)
# (2, 1, u'Paragraph 1')
# (3, 7, u'Paragraph 2')</code></pre> 
              <p>You can shut off this feature by passing <code class="inline-code">store_line_numbers=False` into the ``BeautifulSoup</code> constructor:</p> 
                <pre><code class="python">markup = &quot;&lt;p\n&gt;Paragraph 1&lt;/p&gt;\n    &lt;p&gt;Paragraph 2&lt;/p&gt;&quot;
soup = BeautifulSoup(markup, 'html.parser', store_line_numbers=False)
soup.p.sourceline
# None</code></pre> 
                <p>This feature is new in 4.8.1, and the parsers based on lxml don’t support it.</p>

        </section>

        <section class="main-section" id="13Comparing_objects_for_equality#">
          <header><span class="number section-number">13</span>Comparing objects for equality<a class="header-anchor" href="#13Comparing_objects_for_equality#">#</a></header>
          <p>Beautiful Soup says that two <code class="inline-code">NavigableString</code> or <code class="inline-code">Tag</code> objects are equal when they represent the same HTML or XML markup. In this example, the two <code class="inline-code">&lt;b&gt;</code> tags are treated as equal, even though they live in different parts of the object tree, because they both look like “<code class="inline-code">&lt;b&gt;pizza&lt;/b&gt;</code>”:</p>
          <pre><code class="python">markup = &quot;&lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;&quot;
soup = BeautifulSoup(markup, 'html.parser')
first_b, second_b = soup.find_all('b')
print first_b == second_b
# True

print first_b.previous_element == second_b.previous_element
# False</code></pre> 
            <p>If you want to see whether two variables refer to exactly the same object, use <i>is</i>:</p>
            <pre><code class="python">print first_b is second_b
# False</code></pre>

        </section>

        <section class="main-section" id="14Copying_Beautiful_Soup_objects#">
          <header><span class="number section-number">14</span>Copying Beautiful Soup objects<a class="header-anchor" href="#14Copying_Beautiful_Soup_objects#">#</a></header>
          <p>You can use <code class="inline-code">copy.copy()</code> to create a copy of any <code class="inline-code">Tag</code> or <code class="inline-code">NavigableString</code>:</p> 
          <pre><code class="python">import copy
p_copy = copy.copy(soup.p)
print p_copy
# &lt;p&gt;I want &lt;b&gt;pizza&lt;/b&gt; and more &lt;b&gt;pizza&lt;/b&gt;!&lt;/p&gt;</code></pre> 
            <p>The copy is considered equal to the original, since it represents the same markup as the original, but it’s not the same object:</p>
              <pre><code class="python">print soup.p == p_copy
# True

print soup.p is p_copy
# False</code></pre> 
              <p>The only real difference is that the copy is completely detached from the original Beautiful Soup object tree, just as if <code class="inline-code">extract()</code> had been called on it:</p> 
                <pre><code class="python">print p_copy.parent
# None</code></pre> 
                <p>This is because two different <code class="inline-code">Tag</code> objects can’t occupy the same space at the same time.</p>

        </section>

        <section class="main-section" id="15Parsing_only_part_of_a_document#">
          <header><span class="number section-number">15</span>Parsing only part of a document<a class="header-anchor" href="#15Parsing_only_part_of_a_document#">#</a></header>
          <p>Let’s say you want to use Beautiful Soup look at a document’s <code class="inline-code">&lt;a&gt;</code> tags. It’s a waste of time and memory to parse the entire document and then go over it again looking for <code class="inline-code">&lt;a&gt;</code> tags. It would be much faster to ignore everything that wasn’t an <code class="inline-code">&lt;a&gt;</code> tag in the first place. The <code class="inline-code">SoupStrainer</code> class allows you to choose which parts of an incoming document are parsed. You just create a <code class="inline-code">SoupStrainer</code> and pass it in to the <code class="inline-code">BeautifulSoup</code> constructor as the <code class="inline-code">parse_only</code> argument.</p>
          <p>(Note that <em>this feature won’t work if you’re using the html5lib parser</em>. If you use html5lib, the whole document will be parsed, no matter what. This is because html5lib constantly rearranges the parse tree as it works, and if some part of the document didn’t actually make it into the parse tree, it’ll crash. To avoid confusion, in the examples below I’ll be forcing Beautiful Soup to use Python’s built-in parser.)</p> 
  

          <h4 class="sub-header" id="SoupStrainer">
            <span class="number sub-section-number">15.1</span><code class="inline-code">SoupStrainer</code><a class="header-anchor" href="#SoupStrainer">#</a>
          </h4>
          <p>The <code class="inline-code">SoupStrainer</code> class takes the same arguments as a typical method from <a href="#7Searching_the_tree#">Searching the tree</a>: <a href="#The_name_Argument">name</a>, <a href="#Searching_By_CSS_Class">attrs</a>, <a href="#The_string_Argument">string</a>, and <a href="#The_Keyword_Arguments">**kwargs</a>. Here are three <code class="inline-code">SoupStrainer</code> objects:</p> 
          <pre><code class="python">from bs4 import SoupStrainer
 
only_a_tags = SoupStrainer(&quot;a&quot;)

only_tags_with_id_link2 = SoupStrainer(id=&quot;link2&quot;)

def is_short_string(string):
    return len(string) &lt; 10

only_short_strings = SoupStrainer(string=is_short_string)</code></pre>
        <p>I’m going to bring back the “three sisters” document one more time, and we’ll see what the document looks like when it’s parsed with these three <code class="inline-code">SoupStrainer</code> objects:</p> 
        <pre><code class="python">html_doc = &quot;&quot;&quot;
&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were
&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,
&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and
&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;
and they lived at the bottom of a well.&lt;/p&gt;

&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;
&quot;&quot;&quot;

print(BeautifulSoup(html_doc, &quot;html.parser&quot;, parse_only=only_a_tags).prettify())
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;
#  Elsie
# &lt;/a&gt;
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;
#  Lacie
# &lt;/a&gt;
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;
#  Tillie
# &lt;/a&gt;

print(BeautifulSoup(html_doc, &quot;html.parser&quot;, parse_only=only_tags_with_id_link2).prettify())
# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;
#  Lacie
# &lt;/a&gt;

print(BeautifulSoup(html_doc, &quot;html.parser&quot;, parse_only=only_short_strings).prettify())
# Elsie
# ,
# Lacie
# and
# Tillie
# ...
#</code></pre> 
        <p>You can also pass a <code class="inline-code">SoupStrainer</code> into any of the methods covered in <a href="#7Searching_the_tree#">Searching the tree</a>. This probably isn’t terribly useful, but I thought I’d mention it:</p>
        <pre><code class="python">soup = BeautifulSoup(html_doc)
soup.find_all(only_short_strings)
# [u'\n\n', u'\n\n', u'Elsie', u',\n', u'Lacie', u' and\n', u'Tillie',
#  u'\n\n', u'...', u'\n']</code></pre>

        </section>

        <section class="main-section" id="16Troubleshooting#">
          <header><span class="number section-number">16</span>Troubleshooting<a class="header-anchor" href="#16Troubleshooting#">#</a></header>

          <h4 class="sub-header" id="diagnose">
            <span class="number sub-section-number">16.1</span><code class="inline-code">diagnose()</code><a class="header-anchor" href="#diagnose">#</a>
          </h4>
          <p>If you’re having trouble understanding what Beautiful Soup does to a document, pass the document into the <code class="inline-code">diagnose()</code> function. (New in Beautiful Soup 4.2.0.) Beautiful Soup will print out a report showing you how different parsers handle the document, and tell you if you’re missing a parser that Beautiful Soup could be using:</p>
          <pre><code class="python">from bs4.diagnose import diagnose
with open(&quot;bad.html&quot;) as fp:
    data = fp.read()
diagnose(data)

# Diagnostic running on Beautiful Soup 4.2.0
# Python version 2.7.3 (default, Aug  1 2012, 05:16:07)
# I noticed that html5lib is not installed. Installing it may help.
# Found lxml version 2.3.2.0
#
# Trying to parse your data with html.parser
# Here's what html.parser did with the document:
# ...</code></pre>
       <p>Just looking at the output of diagnose() may show you how to solve the problem. Even if not, you can paste the output of <code class="inline-code">diagnose()</code> when asking for help.</p> 

          <h4 class="sub-header" id="Errors_When_Parsing_A_Document">
            <span class="number sub-section-number">16.2</span>Errors when parsing a document<a class="header-anchor" href="#Errors_When_Parsing_A_Document">#</a>
          </h4>
          <p>There are two different kinds of parse errors. There are crashes, where you feed a document to Beautiful Soup and it raises an exception, usually an <code class="inline-code">HTMLParser.HTMLParseError</code>. And there is unexpected behavior, where a Beautiful Soup parse tree looks a lot different than the document used to create it.</p> 
          <p>Almost none of these problems turn out to be problems with Beautiful Soup. This is not because Beautiful Soup is an amazingly well-written piece of software. It’s because Beautiful Soup doesn’t include any parsing code. Instead, it relies on external parsers. If one parser isn’t working on a certain document, the best solution is to try a different parser. See <a href="#Installing_A_Parser">Installing a parser</a> for details and a parser comparison.</p> 
          <p>The most common parse errors are <code class="inline-code">HTMLParser.HTMLParseError: malformed start tag</code> and <code class="inline-code">HTMLParser.HTMLParseError: bad end tag</code>. These are both generated by Python’s built-in HTML parser library, and the solution is to <a href="#Installing_A_Parser">install lxml or html5lib.</a></p> 
          <p>The most common type of unexpected behavior is that you can’t find a tag that you know is in the document. You saw it going in, but <code class="inline-code">find_all()</code> returns <code class="inline-code">[]</code> or <code class="inline-code">find()</code> returns <code class="inline-code">None</code>. This is another common problem with Python’s built-in HTML parser, which sometimes skips tags it doesn’t understand. Again, the solution is to <a href="#Installing_A_Parser">install lxml or html5lib.</a></p> 
  

          <h4 class="sub-header" id="Version_Mismatch_Problems">
            <span class="number sub-section-number">16.3</span>Version mismatch problems<a class="header-anchor" href="#Version_Mismatch_Problems">#</a>
          </h4>
          <ul> 
            <li><code class="inline-code">SyntaxError: Invalid syntax</code> (on the line <code class="inline-code">ROOT_TAG_NAME = u'[document]'</code>): Caused by running the Python 2 version of Beautiful Soup under Python 3, without converting the code.</li> 
            <li><code class="inline-code">ImportError: No module named HTMLParser</code> - Caused by running the Python 2 version of Beautiful Soup under Python 3.</li> 
            <li><code class="inline-code">ImportError: No module named html.parser</code> - Caused by running the Python 3 version of Beautiful Soup under Python 2.</li> 
            <li><code class="inline-code">ImportError: No module named BeautifulSoup</code> - Caused by running Beautiful Soup 3 code on a system that doesn’t have BS3 installed. Or, by writing Beautiful Soup 4 code without knowing that the package name has changed to <code class="inline-code">bs4</code>.</li> 
            <li><code class="inline-code">ImportError: No module named bs4</code> - Caused by running Beautiful Soup 4 code on a system that doesn’t have BS4 installed.</li> 
           </ul> 

          <h4 class="sub-header" id="Parsing_XML">
            <span class="number sub-section-number">16.4</span>Parsing XML<a class="header-anchor" href="#Parsing_XML">#</a>
          </h4>
          <p>By default, Beautiful Soup parses documents as HTML. To parse a document as XML, pass in “xml” as the second argument to the <code class="inline-code">BeautifulSoup</code> constructor:</p>
          <pre><code class="python">soup = BeautifulSoup(markup, "xml")</code></pre>
          <p>You’ll need to <a href="#Installing_A_Parser">have lxml installed</a>.</p> 

          <h4 class="sub-header" id="Other_Parser_Problems">
            <span class="number sub-section-number">16.5</span>Other parser problems<a class="header-anchor" href="#Other_Parser_Problems">#</a>
          </h4>
          <ul> 
            <li>If your script works on one computer but not another, or in one virtual environment but not another, or outside the virtual environment but not inside, it’s probably because the two environments have different parser libraries available. For example, you may have developed the script on a computer that has lxml installed, and then tried to run it on a computer that only has html5lib installed. See <a href="#Differences_Between_Parsers">Differences between parsers</a> for why this matters, and fix the problem by mentioning a specific parser library in the <code class="inline-code">BeautifulSoup</code> constructor.</li> 
            <li>Because <a href="http://www.w3.org/TR/html5/syntax.html#syntax">HTML tags and attributes are case-insensitive</a>, all three HTML parsers convert tag and attribute names to lowercase. That is, the markup <code class="inline-code">&lt;TAG&gt;&lt;/TAG&gt;</code> is converted to <code class="inline-code">&lt;tag&gt;&lt;/tag&gt;</code>. If you want to preserve mixed-case or uppercase tags and attributes, you’ll need to <a href="#Parsing_XML">parse the document as XML.</a></li> 
           </ul> 

          <h4 class="sub-header" id="Miscellaneous">
            <span class="number sub-section-number">16.6</span>Miscellaneous<a class="header-anchor" href="#Miscellaneous">#</a>
          </h4>
          <ul> 
            <li><code class="inline-code">UnicodeEncodeError: 'charmap' codec can't encode character u'\xfoo' in position bar</code> (or just about any other <code class="inline-code">UnicodeEncodeError</code>) - This is not a problem with Beautiful Soup. This problem shows up in two main situations. First, when you try to print a Unicode character that your console doesn’t know how to display. (See <a href="http://wiki.python.org/moin/PrintFails">this page on the Python wiki</a> for help.) Second, when you’re writing to a file and you pass in a Unicode character that’s not supported by your default encoding. In this case, the simplest solution is to explicitly encode the Unicode string into UTF-8 with <code class="inline-code">u.encode(&quot;utf8&quot;)</code>.</li> 
            <li><code class="inline-code">KeyError: [attr]</code> - Caused by accessing <code class="inline-code">tag['attr']</code> when the tag in question doesn’t define the <code class="inline-code">attr</code> attribute. The most common errors are <code class="inline-code">KeyError: 'href'</code> and <code class="inline-code">KeyError: 'class'</code>. Use <code class="inline-code">tag.get('attr')</code> if you’re not sure <code class="inline-code">attr</code> is defined, just as you would with a Python dictionary.</li> 
            <li><code class="inline-code">AttributeError: 'ResultSet' object has no attribute 'foo'</code> - This usually happens because you expected <code class="inline-code">find_all()</code> to return a single tag or string. But <code class="inline-code">find_all()</code> returns a _list_ of tags and strings–a <code class="inline-code">ResultSet</code> object. You need to iterate over the list and look at the <code class="inline-code">.foo</code> of each one. Or, if you really only want one result, you need to use <code class="inline-code">find()</code> instead of <code class="inline-code">find_all()</code>.</li> 
            <li><code class="inline-code">AttributeError: 'NoneType' object has no attribute 'foo'</code> - This usually happens because you called <code class="inline-code">find()</code> and then tried to access the <i>.foo`</i> attribute of the result. But in your case, <code class="inline-code">find()</code> didn’t find anything, so it returned <code class="inline-code">None</code>, instead of returning a tag or a string. You need to figure out why your <code class="inline-code">find()</code> call isn’t returning anything.</li> 
           </ul>

          <h4 class="sub-header" id="Improving_Performance">
            <span class="number sub-section-number">16.7</span>Improving Performance<a class="header-anchor" href="#Improving_Performance">#</a>
          </h4>
          <p>Beautiful Soup will never be as fast as the parsers it sits on top of. If response time is critical, if you’re paying for computer time by the hour, or if there’s any other reason why computer time is more valuable than programmer time, you should forget about Beautiful Soup and work directly atop <a href="http://lxml.de/">lxml</a>.</p> 
          <p>That said, there are things you can do to speed up Beautiful Soup. If you’re not using lxml as the underlying parser, my advice is to <a href="#Installing_A_Parser">start</a>. Beautiful Soup parses documents significantly faster using lxml than using html.parser or html5lib.</p> 
          <p>You can speed up encoding detection significantly by installing the <a href="http://pypi.python.org/pypi/cchardet/">cchardet</a> library.</p> 
          <p><a href="#15Parsing_only_part_of_a_document#">Parsing only part of a document</a> won’t save you much time parsing the document, but it can save a lot of memory, and it’ll make <i>searching</i> the document much faster.</p> 
  

        </section>

        <section class="main-section" id="17Translating_this_document#">
          <header><span class="number section-number">17</span>Translating this document<a class="header-anchor" href="#17Translating_this_document#">#</a></header>
          <p>New translations of the Beautiful Soup documentation are greatly appreciated. Translations should be licensed under the MIT license, just like Beautiful Soup and its English documentation are.</p> 
          <p>There are two ways of getting your translation into the main code base and onto the Beautiful Soup website:</p> 
          <ul>
           <li>Create a branch of the Beautiful Soup repository, add your translation, and propose a merge with the main branch, the same as you would do with a proposed change to the source code.</li> 
           <li>Send a message to the Beautiful Soup discussion group with a link to your translation, or attach your translation to the message.</li> 
          </ul> 
          <p>Use the Chinese or Brazilian Portuguese translations as your model. In particular, please translate the source file <code class="inline-code">doc/source/index.rst</code>, rather than the HTML version of the documentation. This makes it possible to publish the documentation in a variety of formats, not just HTML.</p> 
  

        </section>

        <section class="main-section" id="18Beautiful_Soup_3#">
          <header><span class="number section-number">18</span>Beautiful Soup 3<a class="header-anchor" href="#18Beautiful_Soup_3#">#</a></header>
          <p>Beautiful Soup 3 is the previous release series, and is no longer being actively developed. It’s currently packaged with all major Linux distributions:</p> 
          <p><code class="inline-code">$ apt-get install python-beautifulsoup</code></p> 
          <p>It’s also published through PyPi as <code class="inline-code">BeautifulSoup</code>.:</p> 
          <p><code class="inline-code">$ easy_install BeautifulSoup</code></p> 
          <p><code class="inline-code">$ pip install BeautifulSoup</code></p> 
          <p>You can also <a href="http://www.crummy.com/software/BeautifulSoup/bs3/download/3.x/BeautifulSoup-3.2.0.tar.gz">download a tarball of Beautiful Soup 3.2.0</a>.</p> 
          <p>If you ran <code class="inline-code">easy_install beautifulsoup</code> or <code class="inline-code">easy_install BeautifulSoup</code>, but your code doesn’t work, you installed Beautiful Soup 3 by mistake. You need to run <code class="inline-code">easy_install beautifulsoup4</code>.</p> 
          <p><a href="http://www.crummy.com/software/BeautifulSoup/bs3/documentation.html">The documentation for Beautiful Soup 3 is archived online</a>.</p>   

          <h4 class="sub-header" id="Porting_Code_To_BS4">
            <span class="number sub-section-number">18.1</span>Porting code to BS4<a class="header-anchor" href="#Porting_Code_To_BS4">#</a>
          </h4>
          <p>Most code written against Beautiful Soup 3 will work against Beautiful Soup 4 with one simple change. All you should have to do is change the package name from <code class="inline-code">BeautifulSoup</code> to <code class="inline-code">bs4</code>. So this:</p> 
          <pre><code class="python">from BeautifulSoup import BeautifulSoup</code></pre>
        <p>becomes this:</p> 
        <pre><code class="python">from bs4 import BeautifulSoup</code></pre><br />
        <ul>
         <li>If you get the <code class="inline-code">ImportError</code> “No module named BeautifulSoup”, your problem is that you’re trying to run Beautiful Soup 3 code, but you only have Beautiful Soup 4 installed.</li> 
         <li>If you get the <code class="inline-code">ImportError</code> “No module named bs4”, your problem is that you’re trying to run Beautiful Soup 4 code, but you only have Beautiful Soup 3 installed.</li> 
        </ul> 
        <p>Although BS4 is mostly backwards-compatible with BS3, most of its methods have been deprecated and given new names for <a href="http://www.python.org/dev/peps/pep-0008/">PEP 8 compliance</a>. There are numerous other renames and changes, and a few of them break backwards compatibility.</p> 
        <p>Here’s what you’ll need to know to convert your BS3 code and habits to BS4:</p>

          <h5 class="sub-header sub-header2" id="You_Need_A_Parser">
            <span class="number sub-section-number">18.1.1</span>You need a parser<a class="header-anchor" href="#You_Need_A_Parser">#</a>
          </h5>
          <p>Beautiful Soup 3 used Python’s <code class="inline-code">SGMLParser</code>, a module that was deprecated and removed in Python 3.0. Beautiful Soup 4 uses <code class="inline-code">html.parser</code> by default, but you can plug in lxml or html5lib and use that instead. See <a href="#Installing_A_Parser">Installing a parser</a> for a comparison.</p> 
          <p>Since <code class="inline-code">html.parser</code> is not the same parser as <code class="inline-code">SGMLParser</code>, you may find that Beautiful Soup 4 gives you a different parse tree than Beautiful Soup 3 for the same markup. If you swap out <code class="inline-code">html.parser</code> for lxml or html5lib, you may find that the parse tree changes yet again. If this happens, you’ll need to update your scraping code to deal with the new tree.</p>   

          <h5 class="sub-header sub-header2" id="Method_Names">
            <span class="number sub-section-number">18.1.2</span>Method names<a class="header-anchor" href="#Method_Names">#</a>
          </h5>
          <ul> 
            <li><code class="inline-code">renderContents</code> -&gt; <code class="inline-code">encode_contents</code></li> 
            <li><code class="inline-code">replaceWith</code> -&gt; <code class="inline-code">replace_with</code></li> 
            <li><code class="inline-code">replaceWithChildren</code> -&gt; <code class="inline-code">unwrap</code></li> 
            <li><code class="inline-code">findAll</code> -&gt; <code class="inline-code">find_all</code></li> 
            <li><code class="inline-code">findAllNext</code> -&gt; <code class="inline-code">find_all_next</code></li> 
            <li><code class="inline-code">findAllPrevious</code> -&gt; <code class="inline-code">find_all_previous</code></li> 
            <li><code class="inline-code">findNext</code> -&gt; <code class="inline-code">find_next</code></li> 
            <li><code class="inline-code">findNextSibling</code> -&gt; <code class="inline-code">find_next_sibling</code></li> 
            <li><code class="inline-code">findNextSiblings</code> -&gt; <code class="inline-code">find_next_siblings</code></li> 
            <li><code class="inline-code">findParent</code> -&gt; <code class="inline-code">find_parent</code></li> 
            <li><code class="inline-code">findParents</code> -&gt; <code class="inline-code">find_parents</code></li> 
            <li><code class="inline-code">findPrevious</code> -&gt; <code class="inline-code">find_previous</code></li> 
            <li><code class="inline-code">findPreviousSibling</code> -&gt; <code class="inline-code">find_previous_sibling</code></li> 
            <li><code class="inline-code">findPreviousSiblings</code> -&gt; <code class="inline-code">find_previous_siblings</code></li> 
            <li><code class="inline-code">getText</code> -&gt; <code class="inline-code">get_text</code></li> 
            <li><code class="inline-code">nextSibling</code> -&gt; <code class="inline-code">next_sibling</code></li> 
            <li><code class="inline-code">previousSibling</code> -&gt; <code class="inline-code">previous_sibling</code></li> 
           </ul> 
           <p>Some arguments to the Beautiful Soup constructor were renamed for the same reasons:</p> 
           <ul> 
            <li><code class="inline-code">BeautifulSoup(parseOnlyThese=...)</code> -&gt; <code class="inline-code">BeautifulSoup(parse_only=...)</code></li> 
            <li><code class="inline-code">BeautifulSoup(fromEncoding=...)</code> -&gt; <code class="inline-code">BeautifulSoup(from_encoding=...)</code></li> 
           </ul> 
           <p>I renamed one method for compatibility with Python 3:</p> 
           <ul> 
            <li><code class="inline-code">Tag.has_key()</code> -&gt; <code class="inline-code">Tag.has_attr()</code></li> 
           </ul> 
           <p>I renamed one attribute to use more accurate terminology:</p> 
           <ul> 
            <li><code class="inline-code">Tag.isSelfClosing</code> -&gt; <code class="inline-code">Tag.is_empty_element</code></li> 
           </ul> 
           <p>I renamed three attributes to avoid using words that have special meaning to Python. Unlike the others, these changes are <em>not backwards compatible.</em> If you used these attributes in BS3, your code will break on BS4 until you change them.</p> 
           <ul> 
            <li><code class="inline-code">UnicodeDammit.unicode</code> -&gt; <code class="inline-code">UnicodeDammit.unicode_markup</code></li> 
            <li><code class="inline-code">Tag.next</code> -&gt; <code class="inline-code">Tag.next_element</code></li> 
            <li><code class="inline-code">Tag.previous</code> -&gt; <code class="inline-code">Tag.previous_element</code></li> 
           </ul>

          <h5 class="sub-header sub-header2" id="Generators">
            <span class="number sub-section-number">18.1.3</span>Generators<a class="header-anchor" href="#Generators">#</a>
          </h5>
          <p>I gave the generators PEP 8-compliant names, and transformed them into properties:</p> 
          <ul> 
           <li><code class="inline-code">childGenerator()</code> -&gt; <code class="inline-code">children</code></li> 
           <li><code class="inline-code">nextGenerator()</code> -&gt; <code class="inline-code">next_elements</code></li> 
           <li><code class="inline-code">nextSiblingGenerator()</code> -&gt; <code class="inline-code">next_siblings</code></li> 
           <li><code class="inline-code">previousGenerator()</code> -&gt; <code class="inline-code">previous_elements</code></li> 
           <li><code class="inline-code">previousSiblingGenerator()</code> -&gt; <code class="inline-code">previous_siblings</code></li> 
           <li><code class="inline-code">recursiveChildGenerator()</code> -&gt; <code class="inline-code">descendants</code></li> 
           <li><code class="inline-code">parentGenerator()</code> -&gt; <code class="inline-code">parents</code></li> 
          </ul> 
          <p>So instead of this:</p> 
          <pre><code class="python">for parent in tag.parentGenerator():
...</code></pre> 
         <p>You can write this:</p> 
         <pre><code class="python">for parent in tag.parents:
...</code></pre> 
         <p>(But the old code will still work.)</p> 
         <p>Some of the generators used to yield <code class="inline-code">None</code> after they were done, and then stop. That was a bug. Now the generators just stop.</p> 
         <p>There are two new generators, <a href="#strings_and_stripped_strings">.strings and .stripped_strings</a>. <code class="inline-code">.strings</code> yields NavigableString objects, and <code class="inline-code">.stripped_strings</code> yields Python strings that have had whitespace stripped.</p> 

          <h5 class="sub-header sub-header2" id="XML">
            <span class="number sub-section-number">18.1.4</span>XML<a class="header-anchor" href="#XML">#</a>
          </h5>
          <p>There is no longer a <code class="inline-code">BeautifulStoneSoup</code> class for parsing XML. To parse XML you pass in “xml” as the second argument to the <code class="inline-code">BeautifulSoup</code> constructor. For the same reason, the <code class="inline-code">BeautifulSoup</code> constructor no longer recognizes the <code class="inline-code">isHTML</code> argument.</p> 
          <p>Beautiful Soup’s handling of empty-element XML tags has been improved. Previously when you parsed XML you had to explicitly say which tags were considered empty-element tags. The <code class="inline-code">selfClosingTags</code> argument to the constructor is no longer recognized. Instead, Beautiful Soup considers any empty tag to be an empty-element tag. If you add a child to an empty-element tag, it stops being an empty-element tag.</p>   

          <h5 class="sub-header sub-header2" id="Entities">
            <span class="number sub-section-number">18.1.5</span>Entities<a class="header-anchor" href="#Entities">#</a>
          </h5>
          <p>An incoming HTML or XML entity is always converted into the corresponding Unicode character. Beautiful Soup 3 had a number of overlapping ways of dealing with entities, which have been removed. The <code class="inline-code">BeautifulSoup</code> constructor no longer recognizes the <code class="inline-code">smartQuotesTo</code> or <code class="inline-code">convertEntities</code> arguments. (<a href="#Unicode_Dammit">Unicode, Dammit</a> still has <code class="inline-code">smart_quotes_to</code>, but its default is now to turn smart quotes into Unicode.) The constants <code class="inline-code">HTML_ENTITIES</code>, <code class="inline-code">XML_ENTITIES</code>, and <code class="inline-code">XHTML_ENTITIES</code> have been removed, since they configure a feature (transforming some but not all entities into Unicode characters) that no longer exists.</p> 
          <p>If you want to turn Unicode characters back into HTML entities on output, rather than turning them into UTF-8 characters, you need to use an <a href="#Output_Formatters">output formatter</a>.</p>  
          <h5 class="sub-header sub-header2" id="Miscellaneous2">
            <span class="number sub-section-number">18.1.6</span>Miscellaneous<a class="header-anchor" href="#Miscellaneous2">#</a>
          </h5>
          <p><a href="#string">Tag.string</a> now operates recursively. If tag A contains a single tag B and nothing else, then A.string is the same as B.string. (Previously, it was None.)</p> 
          <p><a href="#Multi_Valued_Attributes">Multi-valued attributes</a> like <code class="inline-code">class</code> have lists of strings as their values, not strings. This may affect the way you search by CSS class.</p> 
          <p>If you pass one of the <code class="inline-code">find*</code> methods both <a href="#The_string_Argument">string</a> <i>and</i> a tag-specific argument like <a href="#The_name_Argument">name</a>, Beautiful Soup will search for tags that match your tag-specific criteria and whose <a href="#string">Tag.string</a> matches your value for <a href="#The_string_Argument">string</a>. It will <i>not</i> find the strings themselves. Previously, Beautiful Soup ignored the tag-specific arguments and looked for strings.</p> 
          <p>The <code class="inline-code">BeautifulSoup</code> constructor no longer recognizes the <i>markupMassage</i> argument. It’s now the parser’s responsibility to handle markup correctly.</p> 
          <p>The rarely-used alternate parser classes like <code class="inline-code">ICantBelieveItsBeautifulSoup</code> and <code class="inline-code">BeautifulSOAP</code> have been removed. It’s now the parser’s decision how to handle ambiguous markup.</p> 
          <p>The <code class="inline-code">prettify()</code> method now returns a Unicode string, not a bytestring.</p>  

        </section>
      </div>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/simplebar@latest/dist/simplebar.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.17.1/build/highlight.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
    </script>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
  </body>
</html>
